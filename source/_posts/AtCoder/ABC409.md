---
title: AtCoder Beginner Contest 409
date: 2025-6-12 15:19:21
mathjax: true
tags:
- Algorithm
- AtCoder
categories:
- Algorithm
---

## 前言

---

# ABC409 G — Accumulation of Wealth（期望计数 × NTT 卷积）

> **题意概要**
> 初始序列 `A = [1]`，共进行 `N-1` 次操作。
>
> * 设当前未出现的最小正整数为 `mex = m`。
> * 以概率 `p = P / 100` 把 `m` 加入序列；
> * 以概率 `q = 1 − p` 按照出现次数比例随机复制一个已出现的数字并加入序列。
>   求最终序列中每个 `k (1 ≤ k ≤ N)` 出现次数的 **期望**，答案以 `998244353` 取模（有理数用乘法逆元表示）。
<!-- more -->

---

## 1 求期望式子

### 期望拆分

对于每个 $k$，考虑它的出现次数的期望 $E[C_k]$

   $$
   E[C_k] = {第一次出现时刻的概率}\times{之后每次被复制的放大倍数}
   $$

### 第一次出现到底在什么时候？

* 初始只有数字 1，相当于已经有 **1个成功**。
* 之后每做一次操作，要么成功产生新数字（概率$p$），要么失败复制旧数字（概率 $q$）。


于是

* **第 k 种新数字**（即最终的数字 $k$）就是第 $k-1$ 次“成功”。
* 若我们把“成功”记为 1，“失败”记为 0，那么
  第 $k$ 个新数字**正好出现在第 $s$ 步结束后**⇔ 序列前 $s-1$ 步里恰好出现了 $k-2$ 个成功、后面这一步又成功。
  其概率是标准负二项（或“带终止的伯努利串”）

$$
\Pr[S_k=s]=\binom{s-1}{k-2}p^{\,k-1}q^{\,s-k},\qquad s\ge k.
$$

### 出现后,每次操作的增量是多少?

设当前序列长度为 $t$，数字 $k$ 现在已经出现了 $c$ 次。
这一步如果执行 **复制操作**（概率 $q=1-p$）：

* 从已有数字里按出现次数比例抽一个。
* 抽到 $k$ 的概率是 $c/t$。
* 因此若复制发生，$k$ 的期望计数增量是 $\displaystyle \frac{c}{t}$。

综合「复制/不复制」两种情况，本轮之后 $k$ 的期望系数为

$$
c \Bigl(1+\frac{q}{t}\Bigr).
$$

> **只跟当前长度 $t$ 有关，跟 $k$ 本身无关！**
> 所以 **所有** 已经出现过的数字都会被同一个乘数一起放大。

把从它“第一次出现”开始，到最终长度 $N$ 的所有乘数连乘，就得到放大倍数

$$
G(s)=\prod_{t=s}^{N-1}\Bigl(1+\frac{q}{t}\Bigr),
$$

这里 $s$ 是它第一次出现时刻（第一次出现时序列长度就是 $s$）。

### 得到求和公式

   $$
   E[C_k]
   \;=\;
   p^{\,k-1}\sum_{s=k}^{N}
     \binom{s-1}{k-2}\,q^{\,s-k}\,
     \underbrace{\prod_{t=s}^{N-1}\Bigl(1+\frac{q}{t}\Bigr)}_{G(s)}
   $$

#### 小例子直观看看

假设

* $q=\tfrac12$（所以每次有一半概率复制），
* $N=5$，
* 某数字在 $s=3$ 时才首次出现。

那么后面 $t=3,4$ 各乘一次：

$$
G(3)=\Bigl(1+\frac{1/2}{3}\Bigr)\Bigl(1+\frac{1/2}{4}\Bigr)
=\Bigl(1+\frac16\Bigr)\Bigl(1+\frac18\Bigr)
=\frac76\cdot\frac98=\frac{63}{48}=1.3125.
$$

若它更早出现 ($s=2$) 就会多乘一步 $t=2$ 那个因子，放大得更多；
越晚出现，被放大的步数越少。


---

## 2 数学推导

**我们已经有了答案 $E[C_k]$, 考虑如何计算:**

### 1. 预处理G(s)

因为

$$
G(s)=\prod_{t=s}^{N-1}\Bigl(1+\frac{q}{t}\Bigr),\qquad  
G(s)=G(s+1)\Bigl(1+\frac{q}{s}\Bigr),
$$

可以从 $s=N\!-\!1,N\!-\!2,\dots,1$ 倒着递推一遍就全部算出。
这一步不再进入后面的循环，所以 **不需要在枚举 $k,s$ 时重复乘积**。

> **结论：** 求整张 $G(\cdot)$ 表只花一次 $O(N)$。

---

### 2 . 朴素地按公式求T

我们去掉$E[C_k]$里的$p^{k-1}$, 这是个常数,最后计算答案乘回来即可

$$
T_k=\sum_{s=k}^{N}\binom{s-1}{k-2}\;q^{\,s-k}\;G(s)
$$


有了预处理后的 $G(s)$ 和 $q^s$，公式

枚举外层的$k$和公式的$s$,时间复杂度是 $\underline{N\times N}\Rightarrow O(N^2)$。

## 3. FFT/NTT 优化到O(NlogN)

### 优化思路

原公式
$$
T_k\;=\;\sum_{s=k}^{N}\binom{s-1}{k-2}\,q^{\,s-k}\,G(s)\qquad(k\ge2)
$$

* **要同时求出所有 $k=2\ldots N$**
* 直接两重循环是 **$O(N^2)$**，在 $N=10^5$ 时会超时
* 若能写成一次 **卷积（多项式乘法）** 就可用 FFT / NTT 在 **$O(N\log N)$** 内一次性全求完

卷积的标准形是

$$
(f*g)_n=\sum_{i=0}^n f_i\,g_{n-i},
$$

只要把求和凑到这种结构，就能调用$NTT$计算

### 先把下标挪成从0开始
令

$$
n=s-2,\qquad r=k-2,
$$

则



$$
k=r+2,\qquad
s\in[k,N]\;\Leftrightarrow\; n\in[r,N-2],\qquad
k\in[2,N]\;\Leftrightarrow\; r\in[0,N-2].
$$

把原式写成

$$
T_{r+2}
=\sum_{n=r}^{N-2}\binom{n}{r}\;q^{\,n-r}\;G(n+2).
\tag{★}
$$

为了省符号，后面就把 $\;T_{r+2}$ 记成 $Y_r$。

---

### 公式重写
原式

$$
T_k=\sum_{s=k}^{N}\binom{s-1}{k-2}\;q^{\,s-k}\;G(s).
$$

令 $n=s-2,\;r=k-2$(⇒$s=n+2,\;k=r+2$)：

$$
T_{r+2}
=\sum_{n=r}^{N-2}\binom{n}{r}\;q^{\,n+2-(r+2)}\;G(n+2)
=\sum_{n=r}^{N-2}\binom{n}{r}\;q^{\,n-r}\;G(n+2).
$$

现在把 **所有含 $n$** 的因子收进 $B_n$，
同时把 **只含 $r$** 的公共因子 $q^{-r}$ “抠” 出来：

$$
T_{r+2}
= q^{-r}\!\!\sum_{n=r}^{N-2}\binom{n}{r}\bigl(q^{\,n}\,G(n+2)\bigr).
\tag{★}
$$

于是有

$$
\boxed{\,B_n := q^{\,n}\,G(n+2)\,},
\qquad
\boxed{\,Y_r := \sum_{n=r}^{N-2}\binom{n}{r}\,B_n\,},
$$

而

$$
T_{r+2}=q^{-r}\,Y_r.
\tag{★★}
$$


---

### 如何求Y

组合数展开为阶乘

$$
Y_r
=\frac1{r!}\sum_{n=r}^{N-2} \frac{n!}{(n-r)!}\,B_n.
$$

令 $t=n-r\;(t\ge0)$，于是$n = r + t$

- **下限**：当 \( n = r \) 时，代入 \( t = n - r \) ，可得 \( t = r - r = 0 \) ，所以新的求和下限是 \( t = 0 \) 。 
- **上限**：原来的求和上限是 \( n = N - 2 \) ，将 \( n = r + t \) 代入，即 \( r + t = N - 2 \) ，解出 \( t = N - 2 - r \) ，所以新的求和上限是 \( t = N - 2 - r \) 。
 

$$
Y_r
=\frac1{r!}\sum_{t=0}^{N-2-r} (r+t)!\,B_{r+t}\;\frac1{t!}.
$$

把两端分别定义成数组元素：

$$
U_{r+t}:=(r+t)!\,B_{r+t},\qquad
V_t:=\frac1{t!}.
$$

于是

$$
r!\,Y_r\;=\;\sum_{t=0}^{N-2-r} U_{r+t}\,V_t.
\tag{1}
$$

对比卷积标准形
$(f*g)_{i+j}=f_i\,g_j$，

---

### 变为卷积标准式
设 $M=N-1$（注意 $U,V$ 都只到 $N-2$），
新建反向数组

$$
\widetilde U_i:=U_{M-1-i}\quad(i=0\ldots M-1).
$$

把 $r$ 换成卷积系数的位置：

$$
\underbrace{U_{r+t}}_{\text{旧}}\;=\;
\underbrace{\widetilde U_{\,M-1-(r+t)}}_{\text{新}}.
$$

把它塞回式 (1) 得

$$
r!\,Y_r
=\sum_{t=0}^{M-1}\widetilde U_{\,M-1-r-t}\;V_t,
$$

而这正是

$$
(\widetilde U*V)_{M-1-r}.
$$

> **至此已完全变成一次卷积**。
> 做完 NTT 乘法后，我们只需把结果数组的倒数第 $(r+1)$ 个元素除以 $r!$ 就得到 $Y_r$。

---

### 结果还原
计算流程整理如下：

| 名称                 | 数学符号                    | 数组下标范围          | 计算方式        |
| ------------------ | ----------------------- | --------------- | ----------- |
| $B_n$              | $q^{n}G(n+2)$           | $n=0\ldots N-2$ | 直接 O(N) 逐项算 |
| $U_n$              | $n!\,B_n$               | 同上              | 乘阶乘         |
| $\widetilde U$     | 反向                      | 直接 `reverse`    |             |
| $V_t$              | $1/t!$                  | $t=0\ldots N-2$ | 预存阶乘逆元      |
| $W=\widetilde U*V$ | NTT 卷积                  | 长度 $2M-1$       | O(N log N)  |
| $Y_r$              | $\dfrac{W_{M-1-r}}{r!}$ | $r=0\ldots N-2$ | 单点除法        |
| $T_k$              | $Y_{k-2}$               | $k=2\ldots N$   | 下标平移        |
| $\mathbb E[C_k]$   | $p^{\,k-1}q^{-k}\,T_k$  | $k\ge2$         | 乘幂；$k=1$ 另算 |

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
using LL = long long;
const LL MOD = 998244353;
const LL G   = 3;                  // 原根

LL mod_pow(LL a, LL e = MOD - 2) {
    LL r = 1;
    for (; e; e >>= 1, a = a * a % MOD)
        if (e & 1) r = r * a % MOD;
    return r;
}

/* ---------- NTT ---------- */
void ntt(vector<LL>& a, bool invert) {
    int n = (int)a.size();
    for (int i = 1, j = 0; i < n; ++i) {
        int bit = n >> 1;
        for (; j & bit; bit >>= 1) j ^= bit;
        j ^= bit;
        if (i < j) swap(a[i], a[j]);
    }
    for (int len = 2; len <= n; len <<= 1) {
        LL wlen = mod_pow(G, (MOD - 1) / len);
        if (invert) wlen = mod_pow(wlen);
        for (int i = 0; i < n; i += len) {
            LL w = 1;
            for (int j = 0; j < len / 2; ++j) {
                LL u = a[i + j], v = a[i + j + len / 2] * w % MOD;
                a[i + j]         = (u + v) % MOD;
                a[i + j + len/2] = (u - v + MOD) % MOD;
                w = w * wlen % MOD;
            }
        }
    }
    if (invert) {
        LL inv_n = mod_pow(n);
        for (LL &x : a) x = x * inv_n % MOD;
    }
}

vector<LL> convolution(vector<LL> a, vector<LL> b) {
    int n = 1;
    int need = (int)a.size() + (int)b.size() - 1;
    while (n < need) n <<= 1;
    a.resize(n); b.resize(n);
    ntt(a, false); ntt(b, false);
    for (int i = 0; i < n; ++i) a[i] = a[i] * b[i] % MOD;
    ntt(a, true);
    a.resize(need);
    return a;
}

/* ---------- 主算法 ---------- */
const int MAXN = 100000 + 5;
LL fac[MAXN], ifac[MAXN], inv[MAXN];

void pre_factorial(int n) {
    fac[0] = 1;
    for (int i = 1; i <= n; ++i) fac[i] = fac[i - 1] * i % MOD;
    ifac[n] = mod_pow(fac[n]);
    for (int i = n; i; --i) ifac[i - 1] = ifac[i] * i % MOD;
    for (int i = 1; i <= n; ++i) inv[i] = fac[i - 1] * ifac[i] % MOD;  // i^{-1}
}

void solve() {
    int N, Pper;
    cin >> N >> Pper;

    const LL inv100 = mod_pow(100);
    LL p = Pper * inv100 % MOD;
    LL q = (1 - p + MOD) % MOD;

    /* --- 特判 --- */
    if (Pper == 0) {              // 永远复制
        cout << N << '\n';
        for (int k = 2; k <= N; ++k) cout << 0 << '\n';
        return;
    }
    if (Pper == 100) {            // 永远新颜色
        for (int k = 1; k <= N; ++k) cout << 1 << '\n';
        return;
    }

    pre_factorial(N);

    /* 1. 预处理 G(s) */
    vector<LL> Gval(N + 2, 1);
    for (int s = N - 1; s >= 1; --s) {
        Gval[s] = Gval[s + 1] * (1 + q * inv[s] % MOD) % MOD;
    }

    /* 2. A_n = G(n) * q^n */
    vector<LL> pow_q(N + 1, 1);
    for (int i = 1; i <= N; ++i) pow_q[i] = pow_q[i - 1] * q % MOD;

    vector<LL> A(N + 1);
    for (int n = 0; n <= N; ++n)
        A[n] = Gval[n] * pow_q[n] % MOD;

    /* 3. 构造卷积所需数组 */
    int M = N - 1;                       // |B| = N-1  (对应 n' = 0..N-2)
    vector<LL> B(M);
    for (int i = 0; i < M; ++i) B[i] = A[i + 2];

    vector<LL> U(M);                     // U_n = B_n * n!
    for (int i = 0; i < M; ++i) U[i] = B[i] * fac[i] % MOD;

    vector<LL> V(M);                     // V_t = 1 / t!
    for (int i = 0; i < M; ++i) V[i] = ifac[i];

    reverse(U.begin(), U.end());         // 卷积需要反序

    vector<LL> C = convolution(U, V);    // 长度 2*M-1

    /* 4. 预计算 p^{k-1}, q^{-k} */
    vector<LL> pow_p(N + 1, 1), pow_inv_q(N + 1, 1);
    for (int i = 1; i <= N; ++i) pow_p[i]      = pow_p[i - 1]      * p % MOD;
    LL inv_q = mod_pow(q);
    for (int i = 1; i <= N; ++i) pow_inv_q[i] = pow_inv_q[i - 1] * inv_q % MOD;

    /* 5. 输出 */
    vector<LL> ans(N + 1);
    ans[1] = Gval[1];                    // k = 1

    for (int k = 2; k <= N; ++k) {
        int k2   = k - 2;                // r = k-2
        int idx  = M - 1 - k2;           // 对应卷积位置
        LL Yp    = (idx >= 0 && idx < (int)C.size()) ? C[idx] : 0;
        LL Tk    = Yp * ifac[k2] % MOD;  // T_k
        ans[k]   = Tk * pow_p[k - 1] % MOD * pow_inv_q[k] % MOD;
    }

    for (int k = 1; k <= N; ++k) cout << ans[k] << '\n';
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T = 1;
    while (T--) {
        solve();
    }
    return 0;
}
```