---
title: Biweekly Contest 157
date: 2025-5-26 16:12:28
mathjax: true
tags:
- Algorithm
categories:
- LeetCode
---

# contest info

- [Contest Link](https://leetcode.com/contest/biweekly-contest-157/)
- Problem ID: 3556-3559
- Difficult: Medium-Medium-Medium-Hard

<!-- more -->
- 题目分布

| 题号 | 题目标签    | 通过状态 |
| ---- | ----------- | -------- |
| 1    | 素数判断    | ✅       |
| 2    | 贪心, dp    | ✅       |
| 3    | dp          | ✅       |
| 4    | kruskal,dsu | ✅       |

## T1:

## T2

sol1:
贪心地想，这个子串的右端点越小越好，这样后面能选的子串就越多。

选了右端点为 i 的子串后，问题变成从$[i+1,n−1]$中能选多少个子串，这是一个和原问题相似，规模更小的子问题。可以递归/迭代解决。

sol2:
$f[i]$以$i$结尾的最大划分数
$f[i]=\max(f[j])+1$, 其中$i$和$j$表示的是相同的字母,且$i-j\geq3$

时间复杂度$O(N)$

## T3

首先选哪个是不影响答案的, 假设深度最深是$x$(根节点深度是$1$), 那么路径上的边数是$x-1$, 我们记为$n=x-1$
题目要求边权重之和是奇数, 等价于要选奇数条边的权值是 1, 也即是说答案是
$$\binom{n}{1}+\binom{n}{3}+\binom{n}{5}+...=\sum_{i是奇数}\binom{n}{i}$$
对于这个题目来说,预处理出阶乘和逆,然后直接算就可以了

```

typedef long long LL;
typedef unsigned long long ULL;

constexpr int mod = 1'000'000'007;
constexpr int maxn = 100000 + 13;
int f[maxn], g[maxn];

void factorial() {
    memset(f, 0, sizeof(f));
    memset(g, 0, sizeof(g));
    for (int i = 0; i < maxn; i += 1)
        f[i] = i ? 1LL * f[i - 1] * i % mod : 1;
    for (int i = 1; i < maxn; i += 1)
        g[i] = i == 1 ? 1 : 1LL * (mod - mod / i) * g[mod % i] % mod;
    for (int i = 0; i < maxn; i += 1)
        g[i] = g[i] ? 1LL * g[i - 1] * g[i] % mod : 1;
}

// 组合数
LL comb(int n, int m) {
    if (n < m || n < 0 || m < 0)
        return 0;
    return 1LL * f[n] * g[m] % mod * g[n - m] % mod;
}

class Solution {
   public:
    int assignEdgeWeights(vector<vector<int>>& edges) {
        factorial();
        int n = edges.size();
        vector<vector<int>> g(n + 1);
        for (auto& e : edges) {
            int u = e[0], v = e[1];
            u--, v--;
            g[u].push_back(v);
            g[v].push_back(u);
        }

        int ans = 0;
        auto dfs = [&](auto&& dfs, int u, int fa, int d) -> void {
            ans = max(ans, d);
            for (int v : g[u]) {
                if (v == fa)
                    continue;
                dfs(dfs, v, u, d + 1);
            }
        };

        dfs(dfs, 0, -1, 1);
        int x = ans - 1;
        // res = C(n, 1) + C(n, 3) + ...
        LL res = 0;
        for (int i = 1; i <= x; i += 2) {
            res += comb(x, i);
            res %= mod;
        }
        return res;
    }
};
```

## T4

题目是 T3 的加强版,多组询问
思路和 T3 一样,多组询问的话.我们可以通过求$LCA$, 然后$u和v$的路径长度
$$dist(u, v)=dist(root, u)+dist(root, v)-2*dist(root, lca(u, v))$$

单组求和我们通过数学技巧优化组合计算, 时间复杂度为$O(logN)$

利用二项式定理的一些简单变形，可以很快得到下面优美的结果：

$$
\sum_{\substack{k=1\\k\ \text{奇}}}^{n} \binom{n}{k}
=\frac{(1+1)^n - (1-1)^n}{2}
=\frac{2^n - 0}{2}
=2^{\,n-1}.
$$

1. $(1+1)^n=\displaystyle\sum_{k=0}^n\binom{n}{k}$ —— 所有项之和。
2. $(1-1)^n=\displaystyle\sum_{k=0}^n\binom{n}{k}(-1)^k$ —— 奇数项带负号，偶数项带正号。
3. 将二式相减：

   $$
   (1+1)^n - (1-1)^n
   =\sum_{k=0}^n\binom{n}{k}\bigl[1-(-1)^k\bigr]
   =2\sum_{\substack{k=0\\k\ \text{奇}}}^n\binom{n}{k}.
   $$

4. 因此，奇数项之和＝$\bigl((1+1)^n - (1-1)^n\bigr)/2 =2^{n-1}$。

---

**结论**：

$$
\boxed{\sum_{k\text{ 奇}} \binom{n}{k} = 2^{\,n-1}.}
$$

```
#include <bits/stdc++.h>
using namespace std;

#ifdef LOCAL
#include "C:\zwl\files\docs\debug.h"
#else
#define debug(...) 42
#endif
typedef long long LL;
typedef unsigned long long ULL;

const LL mod = 1e9 + 7;
LL powmod(LL a, LL b) {
    LL res = 1;
    a %= mod;
    assert(b >= 0);
    for (; b; b >>= 1) {
        if (b & 1)
            res = res * a % mod;
        a = a * a % mod;
    }
    return res;
}

// 2**17 >= MAXN
static const int MAXN = 100005;
static const int LOG = 17;

int n;                             // 节点个数
vector<pair<int, int>> adj[MAXN];  // 图的边表示
int up[LOG + 1][MAXN];             // 倍增数组
int depth[MAXN];                   // 深度数组, 0是根节点 depth[0]=0;
long long dist0[MAXN];             // 根节点到每个节点的距离
class Solution {
   public:
    void dfs(int u, int p) {
        up[0][u] = p;
        for (auto& e : adj[u]) {
            int v = e.first, w = e.second;
            if (v == p)
                continue;
            depth[v] = depth[u] + 1;
            dist0[v] = dist0[u] + w;
            dfs(v, u);
        }
    }

    int lca0(int u, int v) {
        if (depth[u] < depth[v])
            swap(u, v);
        int diff = depth[u] - depth[v];
        for (int k = 0; k <= LOG; ++k) {
            if (diff & (1 << k)) {
                u = up[k][u];
            }
        }
        if (u == v)
            return u;
        for (int k = LOG; k >= 0; --k) {
            if (up[k][u] != up[k][v]) {
                u = up[k][u];
                v = up[k][v];
            }
        }
        return up[0][u];
    }

    // u, v 是节点编号, 返回 u, v 之间的距离
    long long dist(int u, int v) {
        int w = lca0(u, v);
        return dist0[u] + dist0[v] - 2LL * dist0[w];
    }

    void lca_init(vector<vector<int>>& edges) {
        n = edges.size() + 1;  // 节点个数是边的数 +1
        for (int i = 1; i <= n; ++i) {
            adj[i].clear();
        }
        for (auto& e : edges) {
            int u = e[0], v = e[1], w = 1;
            adj[u].emplace_back(v, w);
            adj[v].emplace_back(u, w);
        }

        memset(up, 0, sizeof(up));
        memset(depth, 0, sizeof(depth));
        memset(dist0, 0, sizeof(dist0));
        depth[0] = 0;
        dist0[0] = 0;

        dfs(1, 0);  // 求出 depth 和 dist0


        // 预处理 up 数组
        for (int k = 1; k <= LOG; ++k) {
            for (int v = 1; v <= n; ++v) {
                up[k][v] = up[k - 1][up[k - 1][v]];
            }
        }
    }
    vector<int> assignEdgeWeights(vector<vector<int>>& edges, vector<vector<int>>& queries) {
        lca_init(edges);

        int q = queries.size();
        vector<int> ans(q);
        for (int i = 0; i < q; ++i) {
            int u = queries[i][0], v = queries[i][1];
            int d = dist(u, v);
            ans[i] = (d == 0 ? 0 : powmod(2, d - 1));
        }
        return ans;
    }
};
```
