---
title: 《Redis 设计与实现》阅读笔记
date: 2025年8月14日01:21:40
mathjax: true
tags:
  - Redis
  - 中间件
categories:
  - Redis
---

## 前言

《Redis 设计与实现》是我很早之前阅读过的一本书, 也是我深入学习的第一个开源的 C 语言项目. 在当时学习的时候, 我从源码的 unit test 逐步调试学习, 学到了不少东西. 但是随着时间的推移, 里面的很多东西都已经忘得差不多了, 如今再次学习这本书, 希望把一些要点记录下来. 主要目的是为了巩固自己的基础知识, 为了工作和面试的需要.

<!-- more -->

## Section 0 前言

### chapter 1 引言

这里应该有如下内容(**先鸽,后续有空再补充**):

- 我们依赖 redis 的版本, 因为随着 redis 的更新, 有可能本文的内容会过时.
- 如何获取源码以及如何在本地或远程调试

## Section 1 数据结构与对象

### chapter 2 简单动态字符串

> 简单动态字符串: **SDS(simple dynamic string)**

重点:

- 在大多数情况下, redis 使用 SDS 作为字符串表示
- 比起 C 字符串, SDS 具有以下优点
  - 常数复杂度获取字符串长度
  - 避免缓冲区溢出
  - 减少修改字符串时带来的内存重分配次数
  - 二进制安全
  - 兼容部分 C 字符串函数

SDS 定义:

```c
struct sdshdr {
    int len; // 字符串长度
    int free; // 字符串未使用的空间
    char buf[]; // 字符串内容
}
```

### chapter 3 链表

重点:

- 链表被广泛用于 redis 的各种功能, 如列表键, 发布/订阅, 慢查询, 监视器等.
- 链表的每个节点都使用一个`/listNode`结构来表示, 每个节点都有一个指向前置节点和后置节点的指针, 所以 redis 的链表是双端链表
- 每个链表使用一个`list`结构来表示, 这个结构包含了指向头节点, 尾节点和链表长度等信息
- redis 是无环链表, 头结点的前置节点和尾结点的后置节点都指向`NULL`
- 链表可以保存各种不同类型的值, 因为链表节点使用了`void*`指针, 所以可以指向任何类型的值

链表节点定义:

```c
type struct listNode {
    struct listNode *prev; // 前置节点
    struct listNode *next; // 后置节点
    void *value; // 节点的值
} listNode;
```

虽然使用多个 listNode 就可以组成链表, 但是使用`list`来持有链表,操作会更方便

```c
type struct list {
    listNode *head; // 指向头节点
    listNode *tail; // 指向尾节点
    unsigned long len; // 链表长度
    // 其他函数
} list;
```

### chapter 4 字典

重点:

- 字典被广泛用于 redis 的各种功能, 其中包括数据库和哈希键
- redis 中的字典使用哈希表作为底层实现, 每个字典带有两个哈希表, 一个平时使用, 另一个仅在进行 rehash 时使用
- 当字典被用作数据库的底层实现, 或者哈希键的底层实现时, redis 使用 Murmurhash2 算法来计算键的哈希值
- 哈希表使用链地址法来解决哈希冲突, 被分配到同一个索引上的多个键值对会连接成一个单向链表
- 在对哈希表进行扩展或收缩操作时, 程序需要将现有哈希表中的所有键值对重新计算哈希值和索引, 并将它们放到新哈希表里面, 并且这个 rehash 过程并不是一次完成的吗而是渐进式完成的

**哈希表**定义:

```c
type struct dictht {
    dictEntry **table; // 哈希表数组
    unsigned long size; // 哈希表大小
    unsigned long sizemask; // 哈希表掩码, 用于计算索引值, 总是等于size-1
    unsigned long used; // 哈希表已有的节点的数量
} dictht;
```

**哈希表节点**定义

```c
type struct dictEntry {
    void *key; // 键
    union {
        void *val; // 值
        uint64_t u64; // 整数值
        int64_t s64; // 有符号整数值
    } v; // 值的联合体, 可以保存多种类型的值
    struct dictEntry *next; // 指向下一个节点, 用于解决哈希冲突
} dictEntry;
```

**字典**定义

```c
type struct dict {
    dictht ht[2]; // 两个哈希表, 一个用于平时使用, 另一个用于rehash
    void *privdata; // 私有数据
    dictType *type; // 类型特定函数
    int trehashidx; // rehash索引, 当rehash不在进行时, 该值为-1
} dict;
```

### chapter 5 跳跃表

> 跳跃表(`skiplist`)是一种有序数据结构. 支持平均 O(logN), 最坏 O(N)复杂度的节点查找

重点:

- 跳跃表是有序集合的底层实现之一
- redis 跳跃表由`zskiplist`和`zskiplistNode`两个结构组成, 其中`zskiplist`用于保存跳跃表信息(比如表头节点, 表尾节点, 长度), 而`zskiplistNode`用于表示跳跃表及诶单
- 每个跳跃表节点的层高都是 1 至 32 之间的随机数
- 在同一个跳跃表中, 多个节点可以包含相同的分值, 但每个节点的成员对象必须是唯一的
- 跳跃表的节点按照分值大小排序, 当分值相同时, 节点按照成员对象的大小进行排序

**跳跃表节点**定义

```c
typedef struct zskiplistNode {
    // 成员对象（存储字符串）
    sds ele;
    // 分值（排序的依据）
    double score;
    // 后退指针（用于从表尾向表头遍历）
    struct zskiplistNode *backward;
    // 层（每个层包含前进指针和跨度）
    struct zskiplistLevel {
        // 前进指针（指向同一层的下一个节点）
        struct zskiplistNode *forward;
        // 跨度（当前节点到下一个节点的距离，用于计算排名）
        unsigned long span;
    } level[];  // 柔性数组，层数动态分配
} zskiplistNode;
```

**跳跃表**定义

```c
typedef struct zskiplist {
    // 表头节点和表尾节点
    struct zskiplistNode *header, *tail;
    // 表中节点的数量
    unsigned long length;
    // 表中层数最大的节点的层数
    int level;
} zskiplist;
```

### chapter 6 整数集合

> 整数集合(`intset`)是集合键的底层实现之一, 当一个集合只包含整数元素, 并且数量不多, redis 就会使用整数集合作为集合间的底层实现

重点:

- 整数集合是集合键的底层实现之一
- 整数集合的底层实现是数组, 这个数组以无序, 无重复的方式保存集合元素, 在有需要时, 程序会根据新添加元素的类型, 改变这个数组的类型
- 升级操作为整数集合带来了操作上的灵活性, 并且尽可能节约了内存
- 整数集合只支持升级, 不支持降级操作

`intset`的结构定义如下:

```c
type struct intset {
    uint32_t encoding; // 编码方式
    uint32_t length; // 元素数量
    int8_t contents[]; // 元素数组
} intset;
```

### chapter 7 压缩列表

> 压缩列表(`ziplist`)是列表键和哈希键的底层实现之一. 当一个列表键只含少量的列表项, 并且每个列表项要么是小整数值, 要么就是长度比较短的字符串, 那么 redis 就会使用压缩列表作为列表键的底层实现. 另外, 当一个哈希键只包含少量键值对, 并且每个键值对的键和值要么是小整数值, 要么就是长度比较短的字符串, redis 就会使用压缩列表作为哈希键的底层实现.

重点:

- 压缩列表是一种为节约内存而开发的顺序性数据结构
- 压缩列表被用于作为列表键和哈希键的底层实现之一
- 压缩列表可以包含多个节点, 每个节点可以保存一个字节数组或整数值
- 添加新节点到压缩列表, 或者删除一个节点, 可能会引发连锁更新操作($O(N^2)$), 但这种出现的几率不高

### chapter 8 对象

> redis 并没有直接使用上述的数据结构,而是基于这些数据结构创建了一个对象系统, 包含字符串对象, 列表对象, 哈希对象, 集合对象, 有序集合对象, 每种对象都用到了至少一种上述的数据结构

#### 字符串对象(string)

int, raw, embstr

#### 列表对象(list)

ziplist, linkedlist

#### 哈希对象(hash)

ziplist, hashtable

#### 集合对象(set)

intset, hashtable

#### 有序集合对象(sorted set)

ziplist, skiplist, hashtable

> 这里补充一下书上没有的

#### 位图(bitmap)

SDS

#### 超日志(hyperloglog)

稀疏矩阵 + 稠密矩阵

#### 地理位置(geospatial)

有序集合（Sorted Set）

## Section 2 单机数据库的实现

### chapter 9 数据库

#### 9.1 服务器中的数据库

redis 服务器将所有数据库都保存在`redisServer`结构的 db 数组里, db 数组的每一项都是一个`redisDb`结构, 每个`redisDb`结构代表一个数据库
在初始化服务器的时候, 会根据`dbnum`来决定创建多少个数据库.
`dbnum`由服务器配置的 database 选项决定. 默认情况下是 16.

```c
struct redisServer {
    // ...
    redisDb *db; // 一个数组, 保存这服务器中的数据库
    int dbnum; // 数据库的数量
    dict *expires; // 过期字典, 保存着键的过期时间
    // ...
}
```

#### 9.2 切换数据库

每个 redis 客户端都有自己的目标数据库, 默认是 0 号数据库. 可以通过`SELECT`命令来切换数据库.

#### 9.3 数据库键空间

redisDb 里的 dict 保存了数据库的所有键值对, 我们称为键空间

```c
typdef struct redisDb {
    // ...
    dict *dict; // 键空间, 保存着数据库中的所有键值对
    // ...
}
```

对 redis 进行读写时, 除了指定的读写操作外,还会执行一些额外的操作

- 读取一个键后(读操作和写操作都要对键进行读取), 服务器会根据键是否存在更新服务器的键命中次数. 这两个值可以在`INFO stats`命令的`keyspace_hits`和`keyspace_misses`字段查看.
- 读取一个键后, 服务器会更新键的 LRU(最后一次使用)事件, 这个值可以用于计算键的闲置时间, 使用`OBJECT idletime <key>` 命令可以查看键的闲置时间.
- 如过服务器读取一个键时发现已经过期, 那么服务器会先删除这个键, 然后执行余下的其他操作.
- 如果有客户端使用`WATCH`命令监听了某个键, 那么服务器在对被监视的键进行修改后, 会将这个键标记为`dirty`, 从而让事务程序注意到这个键已经被修改过
- 服务器每次修改一个键后, 都会对`dirty`键计数器的值增加 1, 这个计数器会触发服务器的持久化以及复制操作
- 服务器开启了数据库通知功能, 那么对键修改后, 服务器将按照配置发送对应的通知.

#### 9.4 设置键的生存时间和过期时间

> 命令: `EXPIRE`, `PEXPIRE`, `EXPIREAT`, `PEXPIREAT`, `TTL`, `PTTL`, `PERSIST`, `SETEX`

#### 9.5 过期键的删除策略

可能的策略:

- 定时删除
- 惰性删除
- 定期删除

#### 9.6 redis 的过期键的删除策略

redis 时间用的是**惰性删除和定期删除**两种策略, 通过配合使用这两种策略, 可以很好地合理使用 CPU 时间和避免浪费内存空间之间取得平衡

- 惰性删除: 所有读写数据库的 redis 命令在执行之前都会调用`expireIfNeeded`函数进行检查,如果过期, 那么就删除这个键
- 定期删除: 每隔一段时间, 就随机抽取一些键, 检查是否过期, 如果过期, 就删除.

#### 9.7 AOF, RDB 和复制功能对过期键的处理

- RDB: 当服务器要生成 RDB 文件时, 会检查键是否过期, 如果过期, 那么就不会将这个键保存到 RDB 文件中
- AOF: 当服务器要生成 AOF 文件时, 会检查键是否过期, 如果过期, 那么就会将`DEL`命令写入 AOF 文件中
- 复制: 从服务器只有在接受到主服务器发来的`DEL`命令后, 才会删除过期键

#### 9.8 数据库通知

> 这个功能可以让客户端通过订阅给定的频道或模式, 来获取数据库中键的变化, 以及数据库中命令的执行情况.

### chapter 10 RDB 持久化

重点:

- RDB 文件用于保存和还原 redis 服务器所有数据库中的键值数据
- `SAVE`命令由服务器进程直接执行保存操作, 会阻塞服务器, 直到 RDB 文件创建完毕
- `BGSAVE`命令由子进程执行保存操作, 不会阻塞服务器
- 服务器状态中会保存所有用`SAVE`命令选项设置的保存条件,当任意一个保存条件被满足, 就会执行`BGSAVE`命令
- RDB 文件是一个经过压缩的二进制文件, 由多个部分组成
- 对于不同类型的键值对, RDB 文件会使用不同的方式来保存它们

### chapter 11 AOF 持久化

重点:

- AOF 文件通过保存所有修改数据库的写命令请求来记录服务器的数据库状态。
- AOF 文件中的所有命令都以 Redis 命令请求协议的格式保存。
- 命令请求会先保存到 AOF 缓冲区里面，之后再定期写入并同步到 AOF 文件。
- `appendfsync` 选项的不同值对 AOF 持久化功能的安全性以及 Redis 服务器的性能有很大的影响。
- 服务器只要载入并重新执行保存在 AOF 文件中的命令，就可以还原数据库本来的状态。
- AOF 重写可以产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。
- AOF 重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有 AOF 文件进行任何读入、分析或者写入操作。
- 在执行 `BGREWRITEAOF` 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新旧两个 AOF 文件所保存的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新旧两个 AOF 文件所保存的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。

### chapter 12 事件

重点:

- Redis 服务器是一个事件驱动程序，服务器处理的事件分为时间事件和文件事件两类。
- 文件事件处理器是基于 Reactor 模式实现的网络通信程序。
- 文件事件是对套接字操作的抽象：每次套接字变为可应答（acceptable）、可写（writable）或者可读（readable）时，相应的文件事件就会产生。
- 文件事件分为 `AE_READABLE` 事件（读事件）和 `AE_WRITABLE` 事件（写事件）两类。
- 时间事件分为定时事件和周期性事件：定时事件只在指定的时间到达一次，而周期性事件则每隔一段时间到达一次。
- 服务器在一般情况下只执行 `serverCron` 函数一个时间事件，并且这个事件是周期性事件。
- 文件事件和时间事件之间是合作关系，服务器会轮流处理这两种事件，并且处理事件的过程中也不会进行抢占。
- 时间事件的实际处理时间通常会比设定的到达时间晚一些。

### chapter 13 客户端

重点:

- 服务器状态结构使用 clients 链表来管理所有客户端状态,新添加的客户端状态会放到链表的末尾
- 客户端状态的 `flags` 属性使用不同标志来表示客户端的角色，以及客户端当前所处的状态。
- 输入缓冲区记录了客户端发送的命令请求，这个缓冲区的大小不能超过 1 GB。
- 命令的参数和参数个数会被记录在客户端状态的 `argv` 和 `argc` 属性里面，而 `cmd` 属性则记录了客户端要执行命令的实现函数。
- 客户端有固定大小缓冲区和可变大小缓冲区两种缓冲区可用，其中固定大小缓冲区的最大大小为 16 KB，而可变大小缓冲区的最大大小不能超过服务器设置的硬性限制值。
- 输出缓冲区限制值有两种，如果输出缓冲区的大小超过了服务器设置的硬性限制，那么客户端会被立即关闭；除此之外，如果客户端在一定时间内，一直超过服务器设置的软性限制，那么客户端也会被关闭。
- 当一个客户端通过网络连接连上服务器时，服务器会为这个客户端创建相应的客户端状态。网络连接关闭、发送了不合协议格式的命令请求、成为 `CLIENT KILL` 命令的目标、空转时间超时、输出缓冲区的大小超出限制，以上这些原因都会造成客户端被关闭。
- 处理 Lua 脚本的伪客户端在服务器初始化时创建，这个客户端会一直存在，直到服务器关闭。
- 载入 AOF 文件时使用的伪客户端在载入工作开始时动态创建，载入工作完毕之后关闭。

### chapter 14 服务器

重点:

- 一个命令请求从发送到完成主要包括以下步骤：1）客户端将命令请求发送给服务器；2）服务器读取命令请求，并分析出命令参数；3）命令执行器根据参数查找命令的实现函数，然后执行实现函数并得出命令回复；4）服务器将命令回复返回给客户端。
- `serverCron` 函数默认每隔 100 毫秒执行一次，它的工作主要包括更新服务器状态信息，处理服务器接收的 `SIGTERM` 信号，管理客户端资源和数据库状态，检查并执行持久化操作等等。
- 服务器从启动到能够处理客户端的命令请求需要执行以下步骤：1）初始化服务器状态；2）载入服务器配置；3）初始化服务器数据结构；4）还原数据库状态；5）执行事件循环。

## Section 3 多机数据库的实现

### chapter 15 复制

### chapter 16 sentinel

### chapter 17 集群

## Section 4 独立功能的实现

### chapter 18 发布与订阅

### chapter 19 事务

### chapter 20 Lua 脚本

### chapter 21 排序

### chapter 22 二进制位数组

### chapter 23 慢查询日志

### chapter 24 监视器
