---
title: 《Redis 设计与实现》阅读笔记
date: 2025年8月14日01:21:40
mathjax: true
tags:
  - Redis
  - 中间件
categories:
  - Redis
---

## 前言

《Redis 设计与实现》是我很早之前阅读过的一本书, 也是我深入学习的第一个开源的 C 语言项目. 在当时学习的时候, 我从源码的 unit test 逐步调试学习, 学到了不少东西. 但是随着时间的推移, 里面的很多东西都已经忘得差不多了, 如今再次学习这本书, 希望把一些要点记录下来. 主要目的是为了巩固自己的基础知识, 为了工作和面试的需要.

<!-- more -->

## Section 0 前言

### chapter 1 引言

这里应该有如下内容(**先鸽,后续有空再补充**):

- 我们依赖 redis 的版本, 因为随着 redis 的更新, 有可能本文的内容会过时.
- 如何获取源码以及如何在本地或远程调试

## Section 1 数据结构与对象

### chapter 2 简单动态字符串

> 简单动态字符串: **SDS(simple dynamic string)**

重点:

- 在大多数情况下, redis 使用 SDS 作为字符串表示
- 比起 C 字符串, SDS 具有以下优点
  - 常数复杂度获取字符串长度
  - 避免缓冲区溢出
  - 减少修改字符串时带来的内存重分配次数
  - 二进制安全
  - 兼容部分 C 字符串函数

SDS 定义:

```c
struct sdshdr {
    int len; // 字符串长度
    int free; // 字符串未使用的空间
    char buf[]; // 字符串内容
}
```

### chapter 3 链表

重点:

- 链表被广泛用于 redis 的各种功能, 如列表键, 发布/订阅, 慢查询, 监视器等.
- 链表的每个节点都使用一个`/listNode`结构来表示, 每个节点都有一个指向前置节点和后置节点的指针, 所以 redis 的链表是双端链表
- 每个链表使用一个`list`结构来表示, 这个结构包含了指向头节点, 尾节点和链表长度等信息
- redis 是无环链表, 头结点的前置节点和尾结点的后置节点都指向`NULL`
- 链表可以保存各种不同类型的值, 因为链表节点使用了`void*`指针, 所以可以指向任何类型的值

链表节点定义:

```c
type struct listNode {
    struct listNode *prev; // 前置节点
    struct listNode *next; // 后置节点
    void *value; // 节点的值
} listNode;
```

虽然使用多个 listNode 就可以组成链表, 但是使用`list`来持有链表,操作会更方便

```c
type struct list {
    listNode *head; // 指向头节点
    listNode *tail; // 指向尾节点
    unsigned long len; // 链表长度
    // 其他函数
} list;
```

### chapter 4 字典

重点:

- 字典被广泛用于 redis 的各种功能, 其中包括数据库和哈希键
- redis 中的字典使用哈希表作为底层实现, 每个字典带有两个哈希表, 一个平时使用, 另一个仅在进行 rehash 时使用
- 当字典被用作数据库的底层实现, 或者哈希键的底层实现时, redis 使用 Murmurhash2 算法来计算键的哈希值
- 哈希表使用链地址法来解决哈希冲突, 被分配到同一个索引上的多个键值对会连接成一个单向链表
- 在对哈希表进行扩展或收缩操作时, 程序需要将现有哈希表中的所有键值对重新计算哈希值和索引, 并将它们放到新哈希表里面, 并且这个 rehash 过程并不是一次完成的吗而是渐进式完成的

**哈希表**定义:

```c
type struct dictht {
    dictEntry **table; // 哈希表数组
    unsigned long size; // 哈希表大小
    unsigned long sizemask; // 哈希表掩码, 用于计算索引值, 总是等于size-1
    unsigned long used; // 哈希表已有的节点的数量
} dictht;
```

**哈希表节点**定义

```c
type struct dictEntry {
    void *key; // 键
    union {
        void *val; // 值
        uint64_t u64; // 整数值
        int64_t s64; // 有符号整数值
    } v; // 值的联合体, 可以保存多种类型的值
    struct dictEntry *next; // 指向下一个节点, 用于解决哈希冲突
} dictEntry;
```

**字典**定义

```c
type struct dict {
    dictht ht[2]; // 两个哈希表, 一个用于平时使用, 另一个用于rehash
    void *privdata; // 私有数据
    dictType *type; // 类型特定函数
    int trehashidx; // rehash索引, 当rehash不在进行时, 该值为-1
} dict;
```

### chapter 5 跳跃表

> 跳跃表(`skiplist`)是一种有序数据结构. 支持平均 O(logN), 最坏 O(N)复杂度的节点查找

重点:

- 跳跃表是有序集合的底层实现之一
- redis 跳跃表由`zskiplist`和`zskiplistNode`两个结构组成, 其中`zskiplist`用于保存跳跃表信息(比如表头节点, 表尾节点, 长度), 而`zskiplistNode`用于表示跳跃表及诶单
- 每个跳跃表节点的层高都是 1 至 32 之间的随机数
- 在同一个跳跃表中, 多个节点可以包含相同的分值, 但每个节点的成员对象必须是唯一的
- 跳跃表的节点按照分值大小排序, 当分值相同时, 节点按照成员对象的大小进行排序

**跳跃表节点**定义

```c
typedef struct zskiplistNode {
    // 成员对象（存储字符串）
    sds ele;
    // 分值（排序的依据）
    double score;
    // 后退指针（用于从表尾向表头遍历）
    struct zskiplistNode *backward;
    // 层（每个层包含前进指针和跨度）
    struct zskiplistLevel {
        // 前进指针（指向同一层的下一个节点）
        struct zskiplistNode *forward;
        // 跨度（当前节点到下一个节点的距离，用于计算排名）
        unsigned long span;
    } level[];  // 柔性数组，层数动态分配
} zskiplistNode;
```

**跳跃表**定义

```c
typedef struct zskiplist {
    // 表头节点和表尾节点
    struct zskiplistNode *header, *tail;
    // 表中节点的数量
    unsigned long length;
    // 表中层数最大的节点的层数
    int level;
} zskiplist;
```

### chapter 6 整数集合

> 整数集合(`intset`)是集合键的底层实现之一, 当一个集合只包含整数元素, 并且数量不多, redis 就会使用整数集合作为集合间的底层实现

重点:

- 整数集合是集合键的底层实现之一
- 整数集合的底层实现是数组, 这个数组以无序, 无重复的方式保存集合元素, 在有需要时, 程序会根据新添加元素的类型, 改变这个数组的类型
- 升级操作为整数集合带来了操作上的灵活性, 并且尽可能节约了内存
- 整数集合只支持升级, 不支持降级操作

`intset`的结构定义如下:

```c
type struct intset {
    uint32_t encoding; // 编码方式
    uint32_t length; // 元素数量
    int8_t contents[]; // 元素数组
} intset;
```

### chapter 7 压缩列表

> 压缩列表(`ziplist`)是列表键和哈希键的底层实现之一. 当一个列表键只含少量的列表项, 并且每个列表项要么是小整数值, 要么就是长度比较短的字符串, 那么 redis 就会使用压缩列表作为列表键的底层实现. 另外, 当一个哈希键只包含少量键值对, 并且每个键值对的键和值要么是小整数值, 要么就是长度比较短的字符串, redis 就会使用压缩列表作为哈希键的底层实现.

重点:

- 压缩列表是一种为节约内存而开发的顺序性数据结构
- 压缩列表被用于作为列表键和哈希键的底层实现之一
- 压缩列表可以包含多个节点, 每个节点可以保存一个字节数组或整数值
- 添加新节点到压缩列表, 或者删除一个节点, 可能会引发连锁更新操作($O(N^2)$), 但这种出现的几率不高

### chapter 8 对象

> redis 并没有直接使用上述的数据结构,而是基于这些数据结构创建了一个对象系统, 包含字符串对象, 列表对象, 哈希对象, 集合对象, 有序集合对象, 每种对象都用到了至少一种上述的数据结构

#### 字符串对象(string)

int, raw, embstr

#### 列表对象(list)

ziplist, linkedlist

#### 哈希对象(hash)

ziplist, hashtable

#### 集合对象(set)

intset, hashtable

#### 有序集合对象(sorted set)

ziplist, skiplist, hashtable

> 这里补充一下书上没有的

#### 位图(bitmap)

SDS

#### 超日志(hyperloglog)

稀疏矩阵 + 稠密矩阵

#### 地理位置(geospatial)

有序集合（Sorted Set）

## Section 2 单机数据库的实现

### chapter 9 数据库

#### 9.1 服务器中的数据库

redis 服务器将所有数据库都保存在`redisServer`结构的 db 数组里, db 数组的每一项都是一个`redisDb`结构, 每个`redisDb`结构代表一个数据库
在初始化服务器的时候, 会根据`dbnum`来决定创建多少个数据库.
`dbnum`由服务器配置的 database 选项决定. 默认情况下是 16.

```c
struct redisServer {
    // ...
    redisDb *db; // 一个数组, 保存这服务器中的数据库
    int dbnum; // 数据库的数量
    dict *expires; // 过期字典, 保存着键的过期时间
    // ...
}
```

#### 9.2 切换数据库

每个 redis 客户端都有自己的目标数据库, 默认是 0 号数据库. 可以通过`SELECT`命令来切换数据库.

#### 9.3 数据库键空间

redisDb 里的 dict 保存了数据库的所有键值对, 我们称为键空间

```c
typdef struct redisDb {
    // ...
    dict *dict; // 键空间, 保存着数据库中的所有键值对
    // ...
}
```

对 redis 进行读写时, 除了指定的读写操作外,还会执行一些额外的操作

- 读取一个键后(读操作和写操作都要对键进行读取), 服务器会根据键是否存在更新服务器的键命中次数. 这两个值可以在`INFO stats`命令的`keyspace_hits`和`keyspace_misses`字段查看.
- 读取一个键后, 服务器会更新键的 LRU(最后一次使用)事件, 这个值可以用于计算键的闲置时间, 使用`OBJECT idletime <key>` 命令可以查看键的闲置时间.
- 如过服务器读取一个键时发现已经过期, 那么服务器会先删除这个键, 然后执行余下的其他操作.
- 如果有客户端使用`WATCH`命令监听了某个键, 那么服务器在对被监视的键进行修改后, 会将这个键标记为`dirty`, 从而让事务程序注意到这个键已经被修改过
- 服务器每次修改一个键后, 都会对`dirty`键计数器的值增加 1, 这个计数器会触发服务器的持久化以及复制操作
- 服务器开启了数据库通知功能, 那么对键修改后, 服务器将按照配置发送对应的通知.

#### 9.4 设置键的生存时间和过期时间

> 命令: `EXPIRE`, `PEXPIRE`, `EXPIREAT`, `PEXPIREAT`, `TTL`, `PTTL`, `PERSIST`, `SETEX`

#### 9.5 过期键的删除策略

可能的策略:

- 定时删除
- 惰性删除
- 定期删除

#### 9.6 redis 的过期键的删除策略

redis 时间用的是**惰性删除和定期删除**两种策略, 通过配合使用这两种策略, 可以很好地合理使用 CPU 时间和避免浪费内存空间之间取得平衡

- 惰性删除: 所有读写数据库的 redis 命令在执行之前都会调用`expireIfNeeded`函数进行检查,如果过期, 那么就删除这个键
- 定期删除: 每隔一段时间, 就随机抽取一些键, 检查是否过期, 如果过期, 就删除.

#### 9.7 AOF, RDB 和复制功能对过期键的处理

- RDB: 当服务器要生成 RDB 文件时, 会检查键是否过期, 如果过期, 那么就不会将这个键保存到 RDB 文件中
- AOF: 当服务器要生成 AOF 文件时, 会检查键是否过期, 如果过期, 那么就会将`DEL`命令写入 AOF 文件中
- 复制: 从服务器只有在接受到主服务器发来的`DEL`命令后, 才会删除过期键

#### 9.8 数据库通知

> 这个功能可以让客户端通过订阅给定的频道或模式, 来获取数据库中键的变化, 以及数据库中命令的执行情况.

### chapter 10 RDB 持久化

重点:

- RDB 文件用于保存和还原 redis 服务器所有数据库中的键值数据
- `SAVE`命令由服务器进程直接执行保存操作, 会阻塞服务器, 直到 RDB 文件创建完毕
- `BGSAVE`命令由子进程执行保存操作, 不会阻塞服务器
- 服务器状态中会保存所有用`SAVE`命令选项设置的保存条件,当任意一个保存条件被满足, 就会执行`BGSAVE`命令
- RDB 文件是一个经过压缩的二进制文件, 由多个部分组成
- 对于不同类型的键值对, RDB 文件会使用不同的方式来保存它们

### chapter 11 AOF 持久化

重点:

- AOF 文件通过保存所有修改数据库的写命令请求来记录服务器的数据库状态。
- AOF 文件中的所有命令都以 Redis 命令请求协议的格式保存。
- 命令请求会先保存到 AOF 缓冲区里面，之后再定期写入并同步到 AOF 文件。
- `appendfsync` 选项的不同值对 AOF 持久化功能的安全性以及 Redis 服务器的性能有很大的影响。
- 服务器只要载入并重新执行保存在 AOF 文件中的命令，就可以还原数据库本来的状态。
- AOF 重写可以产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。
- AOF 重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有 AOF 文件进行任何读入、分析或者写入操作。
- 在执行 `BGREWRITEAOF` 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新旧两个 AOF 文件所保存的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新旧两个 AOF 文件所保存的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。

### chapter 12 事件

重点:

- Redis 服务器是一个事件驱动程序，服务器处理的事件分为时间事件和文件事件两类。
- 文件事件处理器是基于 Reactor 模式实现的网络通信程序。
- 文件事件是对套接字操作的抽象：每次套接字变为可应答（acceptable）、可写（writable）或者可读（readable）时，相应的文件事件就会产生。
- 文件事件分为 `AE_READABLE` 事件（读事件）和 `AE_WRITABLE` 事件（写事件）两类。
- 时间事件分为定时事件和周期性事件：定时事件只在指定的时间到达一次，而周期性事件则每隔一段时间到达一次。
- 服务器在一般情况下只执行 `serverCron` 函数一个时间事件，并且这个事件是周期性事件。
- 文件事件和时间事件之间是合作关系，服务器会轮流处理这两种事件，并且处理事件的过程中也不会进行抢占。
- 时间事件的实际处理时间通常会比设定的到达时间晚一些。

### chapter 13 客户端

重点:

- 服务器状态结构使用 clients 链表来管理所有客户端状态,新添加的客户端状态会放到链表的末尾
- 客户端状态的 `flags` 属性使用不同标志来表示客户端的角色，以及客户端当前所处的状态。
- 输入缓冲区记录了客户端发送的命令请求，这个缓冲区的大小不能超过 1 GB。
- 命令的参数和参数个数会被记录在客户端状态的 `argv` 和 `argc` 属性里面，而 `cmd` 属性则记录了客户端要执行命令的实现函数。
- 客户端有固定大小缓冲区和可变大小缓冲区两种缓冲区可用，其中固定大小缓冲区的最大大小为 16 KB，而可变大小缓冲区的最大大小不能超过服务器设置的硬性限制值。
- 输出缓冲区限制值有两种，如果输出缓冲区的大小超过了服务器设置的硬性限制，那么客户端会被立即关闭；除此之外，如果客户端在一定时间内，一直超过服务器设置的软性限制，那么客户端也会被关闭。
- 当一个客户端通过网络连接连上服务器时，服务器会为这个客户端创建相应的客户端状态。网络连接关闭、发送了不合协议格式的命令请求、成为 `CLIENT KILL` 命令的目标、空转时间超时、输出缓冲区的大小超出限制，以上这些原因都会造成客户端被关闭。
- 处理 Lua 脚本的伪客户端在服务器初始化时创建，这个客户端会一直存在，直到服务器关闭。
- 载入 AOF 文件时使用的伪客户端在载入工作开始时动态创建，载入工作完毕之后关闭。

### chapter 14 服务器

重点:

- 一个命令请求从发送到完成主要包括以下步骤：1）客户端将命令请求发送给服务器；2）服务器读取命令请求，并分析出命令参数；3）命令执行器根据参数查找命令的实现函数，然后执行实现函数并得出命令回复；4）服务器将命令回复返回给客户端。
- `serverCron` 函数默认每隔 100 毫秒执行一次，它的工作主要包括更新服务器状态信息，处理服务器接收的 `SIGTERM` 信号，管理客户端资源和数据库状态，检查并执行持久化操作等等。
- 服务器从启动到能够处理客户端的命令请求需要执行以下步骤：1）初始化服务器状态；2）载入服务器配置；3）初始化服务器数据结构；4）还原数据库状态；5）执行事件循环。

## Section 3 多机数据库的实现

### chapter 15 复制

重点:

- Redis 2.8 以前的复制功能不能高效地处理断线后重复制情况，但 Redis 2.8 新添加的部分重同步功能可以解决这个问题。
- 部分重同步通过复制偏移量、复制积压缓冲区、服务器运行 ID 三个部分来实现。
- 在复制操作刚开始的时候，从服务器会成为主服务器的客户端，并通过向主服务器发送命令请求来执行复制步骤，而在复制操作的后期，主从服务器会互相成为对方的客户端。
- 主服务器通过向从服务器传播命令来更新从服务器的状态，保持主从服务器一致，而从服务器则通过向主服务器发送命令来进行心跳检测，以及命令丢失检测。

### chapter 16 Sentinel

sentinel(哨兵)是 redis 的高可用解决方案, 由一个或多个 sentinel 实例组成的 sentinel 系统可以监视任意多个主服务器, 以及它们的所有从服务器, 并在被监视的主服务器进入下线状态时, 自动将下线主服务器的某个从服务器升级为新的主服务器,
然后由新的主服务器代替已下线的主服务器, 继续处理新的命令.

当 Redis Sentinel 集群检测到主服务器进入“客观下线（ODOWN）”状态后，会通过一系列步骤从现有的从服务器中选举出一个新的主服务器，整个过程称为“故障转移”，核心是**筛选健康的从服务器并按优先级排序**，具体流程如下：

1. 筛选候选从服务器
   首先，Sentinel 会从所有与下线主服务器相连的从服务器中，筛选出“合格”的候选者，排除不符合条件的从服务器，筛选条件包括：

- **状态健康**：从服务器必须处于“在线”状态（未被标记为主观下线或客观下线）。
- **连接正常**：从服务器与原主服务器的断开时间不能过长（具体阈值由配置`sentinel down-after-milliseconds`的 10 倍决定），确保其数据较新（未与主服务器长时间失联导致数据严重滞后）。
- **优先级有效**：从服务器的`replica-priority`（复制优先级，Redis 5.0 前称为`slave-priority`）不能为 0（优先级为 0 的从服务器不会被选为新主）。

2. 对候选从服务器排序

经过筛选后，Sentinel 会对剩余的候选从服务器按以下规则排序，排名第一的将被选为新主服务器：

- **规则 1：优先级最高的优先**  
  从服务器的`replica-priority`配置值越小，优先级越高（例如优先级 1 的从服务器优于优先级 10 的）。这个配置由管理员手动设置，用于指定“更希望被选中”的从服务器（比如性能更好、网络更稳定的节点）。

- **规则 2：复制偏移量最大的优先**  
  若优先级相同，则比较从服务器的**复制偏移量**（记录从服务器同步主服务器数据的进度）。偏移量越大，说明该从服务器同步原主服务器的数据越完整（离主服务器下线前的状态越近），优先被选中（减少数据丢失风险）。

- **规则 3：运行 ID 最小的优先**  
  若优先级和偏移量都相同，则比较从服务器的**运行 ID**（每个 Redis 实例启动时生成的唯一标识），运行 ID 更小的从服务器会被选中（作为最终的“平局 breaker”，确保有唯一结果）。

3. 执行故障转移

当新主服务器被选出后，负责本次故障转移的“领导者 Sentinel”（通过 Sentinel 集群内部选举产生）会执行以下操作：

- 向被选中的从服务器发送`REPLICAOF NO ONE`命令，使其停止复制原主服务器，升级为新主服务器。
- 向其他所有从服务器发送`REPLICAOF <新主服务器IP> <端口>`命令，让它们改为复制新主服务器。
- 更新集群配置，将新主服务器的信息同步给所有 Sentinel 节点，确保后续监控和通信基于新拓扑。

通过以上流程，Sentinel 能快速选出一个“健康、数据完整、符合预期”的从服务器作为新主，保证 Redis 集群的高可用性。整个过程自动化完成，无需人工干预。

重点:

- Sentinel 只是一个运行在特殊模式下的 Redis 服务器，它使用了和普通模式不同的命令表，所以 Sentinel 模式能够使用的命令和普通 Redis 服务器能够使用的命令不同。
- Sentinel 会读入用户指定的配置文件，为每个要被监视的主服务器创建相应的实例结构，并创建连向主服务器的命令连接和订阅连接，其中命令连接用于向主服务器发送命令请求，而订阅连接则用于接收指定频道的消息。
- Sentinel 通过向主服务器发送 `INFO` 命令来获得主服务器属下所有从服务器的地址信息，并为这些从服务器创建相应的实例结构，以及连向这些从服务器的命令连接和订阅连接。
- 在一般情况下，Sentinel 以每十秒一次的频率向被监视的主服务器和从服务器发送 `INFO` 命令，当主服务器处于下线状态，或者 Sentinel 正在对主服务器进行故障转移操作时，Sentinel 向从服务器发送 `INFO` 命令的频率会改为每秒一次。
- 对于监视同一个主服务器和从服务器的多个 Sentinel 来说，它们会以每两秒一次的频率，通过向被监视服务器的 `__sentinel__:hello` 频道发送消息来向其他 Sentinel 宣告自己的存在。
- 每个 Sentinel 也会从 `__sentinel__:hello` 频道中接收其他 Sentinel 发来的信息，并根据这些信息为其他 Sentinel 创建相应的实例结构，以及命令连接。
- Sentinel 只会与主服务器和从服务器创建命令连接和订阅连接，Sentinel 与 Sentinel 之间则只创建命令连接。
- Sentinel 以每秒一次的频率向实例（包括主服务器、从服务器、其他 Sentinel ）发送 `PING` 命令，并根据实例对 `PING` 命令的回复来判断实例是否在线，当一个实例在指定的时长中连续向 Sentinel 发送无效回复时，Sentinel 会将这个实例判断为主观下线。
- 当 Sentinel 将一个主服务器判断为主观下线时，它会向同样监视这个主服务器的其他 Sentinel 进行询问，看它们是否同意这个主服务器已经进入主观下线状态。
- 当 Sentinel 收集到足够多的主观下线投票之后，它会将主服务器判断为客观下线，并发起一次针对主服务器的故障转移操作。

### chapter 17 集群

redis 集群是 redis 提供的分布式数据库解决方案, 集群通过分片(sharding)来进行数据共享, 并提供复制和故障转移功能.

重点:

- 节点通过握手来将其他节点添加到自己所处的集群当中。
- 集群中的 16384 个槽可以分别指派给集群中的各个节点，每个节点都会记录哪些槽指派给了自己，而哪些槽又被指派给了其他节点。
- 节点在接到一个命令请求时，会先检查这个命令请求要处理的键所在的槽是否由自己负责，如果不是的话，节点将向客户端返回一个 MOVED 错误，MOVED 错误携带的信息可以指引客户端转向至正在负责相关槽的节点。
- 对 Redis 集群的重新分片工作是由 redis-trib 负责执行的，重新分片的关键是将属于某个槽的所有键值对从一个节点转移至另一个节点。
- 如果节点 A 正在迁移槽 i 至节点 B，那么当节点 A 没能在自己的数据库中找到命令指定的数据库键时，节点 A 会向客户端返回一个 ASK 错误，指引客户端到节点 B 继续查找指定的数据库键。
- MOVED 错误表示槽的负责权已经从一个节点转移到了另一个节点，而 ASK 错误只是两个节点在迁移槽的过程中使用的一种临时措施。
- 集群里的从节点用于复制主节点，并在主节点下线时，代替主节点继续处理命令请求。
- 集群中的节点通过发送和接收消息来进行通信，常见的消息包括 MEET、PING、PONG、PUBLISH、FAIL 五种。

## Section 4 独立功能的实现

### chapter 18 发布与订阅

重点:

### 18.5 重点回顾

- 服务器状态在 `pubsub_channels` 字典保存了所有频道的订阅关系：`SUBSCRIBE` 命令负责将客户端和被订阅的频道关联到这个字典里面，而 `UNSUBSCRIBE` 命令则负责解除客户端和被退订频道之间的关联。
- 服务器状态在 `pubsub_patterns` 链表保存了所有模式的订阅关系：`PSUBSCRIBE` 命令负责将客户端和被订阅的模式记录到这个链表中，而 `PUNSUBSCRIBE` 命令则负责移除客户端和被退订模式在链表中的记录。
- `PUBLISH` 命令通过访问 `pubsub_channels` 字典来向频道的所有订阅者发送消息，通过访问 `pubsub_patterns` 链表来向所有匹配频道的模式的订阅者发送消息。
- `PUBSUB` 命令的三个子命令都是通过读取 `pubsub_channels` 字典和 `pubsub_patterns` 链表中的信息来实现的。

### chapter 19 事务
重点
- 事务提供了一种将多个命令打包，然后一次性、有序地执行的机制。
- 多个命令会被入队到事务队列中，然后按先进先出（FIFO）的顺序执行。
- 事务在执行过程中不会被中断，当事务队列中的所有命令都被执行完毕之后，事务才会结束。
- 带有 WATCH 命令的事务会将客户端和被监视的键在数据库的 watched_keys 字典中进行关联，当键被修改时，程序会将所有监视被修改键的客户端的 REDIS_DIRTY_CAS 标志打开。
- 只有在客户端的 REDIS_DIRTY_CAS 标志未被打开时，服务器才会执行客户端提交的事务，否则的话，服务器将拒绝执行客户端提交的事务。
- Redis 的事务总是具有 ACID 中的原子性、一致性和隔离性，当服务器运行在 AOF 持久化模式下，并且`appendfsync`选项的值为`always`时，事务也具有耐久性。 


### chapter 20 Lua 脚本

### chapter 21 排序

### chapter 22 二进制位数组

### chapter 23 慢查询日志

### chapter 24 监视器
