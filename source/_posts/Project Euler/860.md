---
title: PE860
date: 2025-9-23 17:29:54
mathjax: true
tags:
  - PE
  - Math
categories:
  - Project Euler
---

## 题目描述

 有 $n$ 个竖直堆，每堆高度为 2，硬币为金（G）或银（S）。Gary 和 Sally 轮流行动：

 * Gary 回合：任选一枚 **金** 币并移除它以及其上的所有硬币；
 * Sally 回合：任选一枚 **银** 币并移除它以及其上的所有硬币；
 * 不能行动者输。
   若一个摆放使 **先手必败**（无论谁先手）则称为 *fair*。
   记 $F(n)$ 为有序摆放（堆的顺序算不同）的 *fair* 数量。已知 $F(2)=4$、$F(10)=63594$。求 $F(9898)\pmod{989898989}$。
---
<!-- more -->

## 分析
这是一个有偏博弈, 不能使用SG定理去解. 需要用到**超现实数**的理论, 我会在文章的末尾附上一些参考资料, 主要是国家集训队的一些论文. 如果懂得了这个理论, 这个题目就很容易去做了. 我想着也是为什么这个题目的难度评级如此低的原因之一吧.

# 思路与关键推导

## 1）单堆（高度 2）的博弈值

把整个局面看作和式博弈的若干独立“堆”的和。由于玩家可选**任意位置**上自己颜色的币并“上掀”，单个高度 2 的堆在康威博弈论中是一个“数”（冷游戏），其值可直接算出：

记堆的自上而下配色为 2 字母串：

* GG：Gary 可走到 0（拿底 G 掀空）或到“单 G”（值为 $1$）；S 无路。故 $\text{GG}=\{0,1\mid\}=2$。
* SS：对称地 $\text{SS}=-2$。
* SG：Gary 走到底 G 掀空到 $0$；S 走顶 S 留“单 G”（值 $1$）。故 $\text{SG}=\{0\mid 1\}=+\tfrac{1}{2}$。
* GS：Gary 走顶 G 留“单 S”（值 $-1$）；S 走底 S 掀空到 $0$。故 $\text{GS}=\{-1\mid 0\}=-\tfrac{1}{2}$。

因此每堆只可能取值于 $\{2,\tfrac{1}{2},-\tfrac{1}{2},-2\}$。多个堆的和仍是“数”，其和的正负/零决定先后手胜负：**和为 0 即先手必败**（第二手胜），即为 *fair*。

## 2）转化为常数项计数

把每堆对应一个“权值”，取两倍以去分数：$\{+4,+1,-1,-4\}$。令形式变量 $t$，一堆的生成函数

$$
P(t)=t^4 + t^1 + t^{-1} + t^{-4}.
$$

则 $n$ 堆的和为 0 的摆放数就是 $P(t)^n$ 的常数项：

$$
F(n)=[t^0]\,(t^4+t+t^{-1}+t^{-4})^n.
$$

把负幂消去：$t^4P(t)=t^8+t^5+t^3+1$。于是

$$
F(n)=[t^{4n}]\,(1+t^3+t^5+t^8)^n.
$$

等价地：长度为 $n$ 的序列，每个位置从权集 $\{0,3,5,8\}$ 中选一个，使得总和为 $4n$。设四类出现次数分别为 $a,b,c,d$，则

$$
\begin{cases}
a+b+c+d=n,\\
3b+5c+8d=4n,
\end{cases}
$$

每组 $(a,b,c,d)$ 对应的有序摆放数为多项式系数 $\displaystyle \frac{n!}{a!\,b!\,c!\,d!}$。因此

$$
F(n)=\sum_{\substack{a+b+c+d=n\\3b+5c+8d=4n}}\frac{n!}{a!\,b!\,c!\,d!}.
$$

把 $a=n-b-c-d$ 代入，只需枚举 $d$ 与 $c$，令 $r=4n-8d$，若 $r-5c$ 能被 3 整除，则 $b=\frac{r-5c}{3}$，且 $a=n-b-c-d\ge 0$；累加对应的多项式系数即可。
小优化：因为 $5\equiv 2\pmod 3$，条件 $r-5c\equiv 0\pmod 3$ 等价于 $c\equiv 2r\pmod 3$，可令 $c$ 以步长 3 枚举。

> 校验：
> $n=2$ 时，满足和为 0 的两堆只有两种配对：$(\text{GG},\text{SS})$ 与 $(\text{SG},\text{GS})$，顺序可互换，共 4 种，故 $F(2)=4$。
> 程序也会给出 $F(10)=63594$。

## 3）复杂度

* 枚举 $d$ 上界 $d\le \lfloor n/2\rfloor$；对每个 $d$，$c$ 的上界约为 $\lfloor(4n-8d)/5\rfloor$，且用步长 3。总循环量 $\approx O(n^2)$。
* 预处理阶乘与逆阶乘 $O(n)$。
  整体时间复杂度 $O(n^2)$，空间复杂度 $O(n)$。


---

## 为何这题和 Nim/SG 不同

**Sprague–Grundy（SG）定理**只对**无偏**博弈成立：双方的可走集合**完全相同**。Nim 与“大多数取石子游戏”是无偏的，直和用 **XOR**。
本题是**有偏（partizan）**：Gary 只能拿**金**，Sally 只能拿**银**，两人可走集合不同，因而 **SG=nimber/XOR 不适用**。要用 **康威组合博弈论（CGT）** 的一般框架来处理。

---
## 和式博弈

**直和（disjunctive sum）**：当一个局面由若干**互不干扰**的子局组成，且每步只能在一个子局内落子，那么整局等价于这些子局的“和”。
本题每次操作只改变**一堆**，其他堆不受影响；因此**整局 = 各堆的直和**。

---
## 康威组合博弈论之CGT速成

* **位置（game）**：$G=\{G^L\mid G^R\}$，其中 $G^L$ 是左方所有后继，$G^R$ 是右方所有后继；空局面 $0=\{\mid\}$。
* 若 $G$ 的选项本身都是“数”，且**任意左选项 $<$ 任意右选项**，则 $G$ 是一个**超现实数**。
  常见基本值：
  $\{0\mid\}=1,\ \{\mid 0\}=-1,\ \{0\mid1\}=\tfrac12,\ \{-1\mid0\}=-\tfrac12,\ \{1\mid\}=2,\ \{\mid-1\}=-2$。
---

## 取值的逐步推导

记顶→底：

1. **GG**：

   * 左可：拿**顶 G**→“单 G”=1；拿**底 G**→掀空=0。
   * 右无路。
     $\{0,1\mid\}$ 中 0 被 1 **支配**（对左更好），化简为 $\{1\mid\}=2$。

2. **SS**：对称得 $\{\mid -1,0\}\to\{\mid -1\}=-2$。

3. **SG**：

   * 左：只能拿**底 G**→掀空=0；
   * 右：只能拿**顶 S**→“单 G”=1。
     $\{0\mid 1\}=\tfrac12$。

4. **GS**：

   * 左：拿**顶 G**→“单 S”=-1；
   * 右：拿**底 S**→掀空=0。
     $\{-1\mid 0\}=-\tfrac12$。

## 总值为 0 ⇔ 先手必败

当一个直和局面是**数** $V$ 时：

* $V>0$：左（Gary）有必胜法；
* $V<0$：右（Sally）有必胜法；
* $V=0$：**P-局面**（后手胜/先手必败）。
  直觉：总值为 0 时，先手任何一步都会把和推离 0，而后手总能在**同一子局**“对消”拉回 0，最终先手先无路可走。

---
## 参考代码
```cpp
#include <bits/stdc++.h>
using namespace std;
using LL = long long;

static const int MOD = 989898989; // 质数

LL qpow(LL a, LL e) {
    LL r = 1 % MOD;
    while (e) {
        if (e & 1) r = (r * a) % MOD;
        a = (a * a) % MOD;
        e >>= 1;
    }
    return r;
}

LL solve_F(int n) {
    vector<LL> fact(n + 1), invf(n + 1);
    fact[0] = 1;
    for (int i = 1; i <= n; ++i) fact[i] = fact[i - 1] * i % MOD;
    invf[n] = qpow(fact[n], MOD - 2);
    for (int i = n; i >= 1; --i) invf[i - 1] = invf[i] * i % MOD;

    auto multinom = [&](int a, int b, int c, int d) -> LL {
        LL res = fact[n];
        res = res * invf[a] % MOD;
        res = res * invf[b] % MOD;
        res = res * invf[c] % MOD;
        res = res * invf[d] % MOD;
        return res;
    };

    LL ans = 0;
    for (int d = 0; d <= n / 2; ++d) {           // 因 8d <= 4n
        int r = 4 * n - 8 * d;                  // 3b + 5c = r
        int maxc = r / 5;
        int c0 = (2 * (r % 3) + 3) % 3;         // r - 5c ≡ 0 (mod 3) ⇔ c ≡ 2r (mod 3)
        for (int c = c0; c <= maxc; c += 3) {
            int rr = r - 5 * c;                 // rr % 3 == 0
            int b = rr / 3;
            int a = n - b - c - d;
            if (a < 0) continue;
            ans += multinom(a, b, c, d);
            if (ans >= MOD) ans -= MOD;
        }
    }
    return ans % MOD;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    using clk = chrono::high_resolution_clock;
    auto t0 = clk::now();

    // 自测：n=2 与 n=10
    // cerr << "F(2)   = " << solve_F(2) << " (expected 4)\n";
    // cerr << "F(10)  = " << solve_F(10) << " (expected 63594)\n";

    int n = 9898;
    cout << solve_F(n) << "\n";

    auto t1 = clk::now();
    double ms = chrono::duration<double, milli>(t1 - t0).count();
    cerr << "Time = " << ms << " ms\n";
    return 0;
}
```

## Bonus O(N)的解法
解决完问题后, 在thread里看了其他人的题解. 有的通过自己的推导,没有使用surreal number也解决了这个题目. 还有O(N)的解法, 主要是两种思路,一种是组合数, 一种是线性递推. 下面给出线性递推的其中一种方法:

###
把

$$
A(x)=(1+x^3+x^5+x^8)^n=\sum_{k=0}^{8n} a_k x^k
$$

看成一个普通多项式，然后**对 $x$ 求导再比对系数**，从而得到系数 $a_k$ 的**线性递推**。这样只要按 $k=1\sim 4n$ 一次推过去，就能在线性时间里拿到我们要的 $a_{4n}$（也就是 $F(n)$）。

---

### 推导步骤

1. 定义

$$
A(x)=(1+x^3+x^5+x^8)^n=\sum_{k\ge0}a_k x^k,\qquad a_0=1.
$$

2. 两边求导：

$$
A'(x)=n(3x^2+5x^4+8x^7)(1+x^3+x^5+x^8)^{n-1}.
$$

3. 乘回去 $(1+x^3+x^5+x^8)$：

$$
(1+x^3+x^5+x^8)A'(x)=n(3x^2+5x^4+8x^7)A(x).
$$

4. 展开并**对比同次幂的系数**。
   写

$$
A'(x)=\sum_{k\ge1} k\,a_k x^{k-1}.
$$

于是左边

$$
(1+x^3+x^5+x^8)A'(x)
=\sum_{k\ge1}k a_k x^{k-1}
+\sum_{k\ge1}k a_k x^{k+2}
+\sum_{k\ge1}k a_k x^{k+4}
+\sum_{k\ge1}k a_k x^{k+7}.
$$

右边

$$
n(3x^2+5x^4+8x^7)A(x)
=n\!\left(3\sum_{k\ge0}a_k x^{k+2}
+5\sum_{k\ge0}a_k x^{k+4}
+8\sum_{k\ge0}a_k x^{k+7}\right).
$$

取\*\*$x^{k-1}$ 的系数\*\*（这样能让目标里出现 $k\,a_k$）：

* 左边给出：$k a_k+(k-3)a_{k-3}+(k-5)a_{k-5}+(k-8)a_{k-8}$；
* 右边给出：$n\big(3a_{k-3}+5a_{k-5}+8a_{k-8}\big)$。

两边相等，整理得

$$
k\,a_k
=(3n+3-k)a_{k-3}+(5n+5-k)a_{k-5}+(8n+8-k)a_{k-8}.
$$

于是

$$
\boxed{\;
a_k=\frac{1}{k}\Big((3n+3-k)a_{k-3}+(5n+5-k)a_{k-5}+(8n+8-k)a_{k-8}\Big),\quad k\ge1,
\;}
$$

并规定 $a_i=0$（当 $i<0$），以及 $a_0=1$。

> 我们要的 $F(n)$ 就是 $[x^{4n}]A(x)=a_{4n}$。

---

### 时间复杂度

递推中 $a_k$ 只依赖 $a_{k-3},a_{k-5},a_{k-8}$，所以按 $k=1,2,\dots,4n$ 顺序一次计算即可，总共 $4n=O(n)$ 次更新。每次是常数次加乘（以及一次“除以 $k$”）。

* 如果在模 $M=989898989$ 下计算，“除以 $k$”用 $k^{-1}$（乘逆元）。
  由于 $k\le4n \ll M$ 且 $M$ 是质数，$k$ 一定可逆。
  逆元可用线性预处理：`inv[1]=1; inv[i]=(M-M/i)*inv[M%i]%M`，整体 $O(n)$。

* 空间只需保存一维数组 $a[0..4n]$：$O(n)$。

---

### 极简伪代码（模 $M$ 版）

```text
want a[4n];  a[0]=1, a[k<0]=0
预处理 inv[1..4n]   // O(n)

for k = 1 .. 4n:
    v = 0
    if k>=3: v += (3n + 3 - k) * a[k-3]
    if k>=5: v += (5n + 5 - k) * a[k-5]
    if k>=8: v += (8n + 8 - k) * a[k-8]
    a[k] = (v % M) * inv[k] % M

answer = a[4n]
```

---

### 参考资料
* [Matrix67:实数、超实数和博弈游戏：数学的结构之美](https://matrix67.com/blog/archives/6333)
*  浅谈超现实数与不平等博弈.pdf 马耀华 国家集训队2021论文集
* 浅谈如何解决不平等博弈问题.pdf 方展鹏 IOI2009冬令营论文
* OI 中的超现实数和不平等博弈问题_杜瑜皓
* On numbers and games, Conway, J. H. (1976).
* Winning ways for your mathematical plays
