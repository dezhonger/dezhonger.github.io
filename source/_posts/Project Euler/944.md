---
title: PE944
date: 2025-9-17 18:00:18
mathjax: true
tags:
  - PE
  - Math
categories:
  - Project Euler
---

## 题目描述

* 给定集合 $E\subseteq\{1,2,\dots,n\}$。如果 $x\in E$ 且存在**另一个** $y\in E$ 使得 $x\mid y$，则称 $x$ 是 $E$ 的 *elevisor*（元素除子）。
* 记 $\mathrm{sev}(E)$ 为 $E$ 中所有 elevisor 的和。
* 设

  $$
  S(n)=\sum_{E\subseteq\{1,2,\dots,n\}}\mathrm{sev}(E).
  $$
* 已知 $S(10)=4927$。目标：计算 $S(10^{14}) \bmod 1234567891$。

**示例**：$\mathrm{sev}(\{1,2,5,6\})=1+2=3$（1|2,1|5,1|6；2|6；5 不整除集合内其他数）。

---
<!-- more -->

## 2. 直接枚举不可行

子集总数是 $2^n$，当 $n=10^{14}$ 更是天文数量，必须用计数+代数化简。

---

## 3. 核心思路：逐元素计贡献（线性性）

对所有子集的和，可以“逐个元素 $x$”拆贡献。固定一个 $x\in\{1,\dots,n\}$，问：在多少个子集中，$x$ 会成为 elevisor？若能数清这类子集数 $C_x$，那么 $x$ 对 $S(n)$ 的总贡献就是 $x\cdot C_x$。

### 3.1 把地盘分两块：倍数与非倍数

令

$$
d = \left\lfloor \frac{n}{x}\right\rfloor,
$$

那么 $\{x,2x,3x,\dots,dx\}$ 是 $[1..n]$ 中 **所有** $x$ 的倍数（共 $d$ 个），其中包含 $x$ 本身（对应 $1\cdot x$）。

把全集 $[1..n]$ 分成两部分：

* 非倍数部分：$\{1,\dots,n\}\setminus \{x,2x,\dots,dx\}$，大小 $n-d$，是否选入子集互相独立，共 $2^{\,n-d}$ 种；
* 倍数组：$\{x,2x,\dots,dx\}$，大小 $d$。

### 3.2 “$x$ 成为 elevisor”的充要条件

在倍数组里，“$x$ 成为 elevisor”要求：

1. 子集必须包含 $x$；
2. 在剩余的 $d-1$ 个倍数里，**至少还要选一个**（作为被它整除的“另一个元素”）。

因此，倍数组内的选择方式有

$$
\underbrace{1}_{\text{必须选 }x}\times
\underbrace{(2^{\,d-1}-1)}_{\text{其余 }d-1\text{ 中至少选 }1}
$$

种。

乘上非倍数自由选择的 $2^{\,n-d}$ 种，总数为

$$
C_x = 2^{\,n-d}\,(2^{\,d-1}-1).
$$

于是固定 $x$ 的贡献为

$$
x\cdot C_x = x\cdot 2^{\,n-d}\,(2^{\,d-1}-1).
$$

把 $d=\lfloor n/x\rfloor$ 代入并化简：

$$
x\cdot 2^{\,n-d}\,(2^{\,d-1}-1)
= x\Big(2^{\,n-1}-2^{\,n-d}\Big),
$$

因为 $2^{\,n-d}\cdot 2^{\,d-1}=2^{\,n-1}$。

### 3.3 汇总得到 $S(n)$

$$
\boxed{
S(n)
= \sum_{x=1}^n x\Big(2^{\,n-1}-2^{\,n-\lfloor n/x\rfloor}\Big)
= \underbrace{2^{\,n-1}\sum_{x=1}^n x}_{\text{项 A}} - \underbrace{\sum_{x=1}^n x\cdot 2^{\,n-\lfloor n/x\rfloor}}_{\text{项 B}}.
}
$$

其中 $\sum_{x=1}^n x = \dfrac{n(n+1)}{2}$ 很简单；难点在项 B。

---

## 4. 项 B 的整除分块

我们要高效计算

$$
B(n)=\sum_{x=1}^n x\cdot 2^{\,n-\lfloor n/x\rfloor}.
$$

设

$$
q=\left\lfloor\frac{n}{x}\right\rfloor.
$$

由于 $q$ 关于 $x$ 单调不增，取相同 $q$ 的 $x$ 连成**一个区间**。把所有 $x$ 按这个 $q$ 分组（等价于**整除分块**）：

### 4.1 固定 $q$ 时的 $x$ 区间与个数（推导要点）

$$
\left\lfloor\frac{n}{x}\right\rfloor=q
\;\Longleftrightarrow\;
q \le \frac{n}{x} < q+1
\;\Longleftrightarrow\;
\frac{n}{q+1} < x \le \frac{n}{q}.
$$

取整得

$$
\boxed{
L(q)=\left\lfloor\frac{n}{q+1}\right\rfloor+1,\qquad
R(q)=\left\lfloor\frac{n}{q}\right\rfloor,
}
$$

于是该组的 $x$ 正好是 $[L(q),\,R(q)]$ 内的所有整数。
**个数**为

$$
R(q)-L(q)+1
= \left\lfloor\frac{n}{q}\right\rfloor-\left\lfloor\frac{n}{q+1}\right\rfloor.
$$

> 代码里常用的“指针法”是等价的：用当前左端点 $L$ 算出
> $q=\lfloor n/L\rfloor$，再令 $R=\lfloor n/q\rfloor$，即可保证 $[L..R]$ 上 $\lfloor n/x\rfloor$ 恒为 $q$。

### 4.2 把项 B 按块重写

当 $\lfloor n/x\rfloor=q$ 时，指数 $n-\lfloor n/x\rfloor = n-q$ 是**常数**，可提到块外。因此

$$
\begin{aligned}
B(n)
&=\sum_{q}\,2^{\,n-q}\sum_{x=L(q)}^{R(q)} x\\
&=\sum_{q}\,2^{\,n-q}\Big(T(R(q))-T(L(q)-1)\Big),
\end{aligned}
$$

其中 $T(m)=1+2+\cdots+m=\tfrac{m(m+1)}{2}$。

**分块个数为何是 $O(\sqrt n)$？**
当 $x\le \sqrt n$ 时，$q=\lfloor n/x\rfloor\ge \sqrt n$，对应约 $\sqrt n$ 个不同的 $q$；
当 $x>\sqrt n$ 时，$q<\sqrt n$，此时不同的 $q$ 只有 $\{1,\dots,\lfloor\sqrt n\rfloor\}$ 这么多。两段相加，总块数 $O(\sqrt n)$。

---

## 5. 模运算细节

* 模数 $M=1234567891$ 是**素数**。
* 等差和 $\dfrac{(L+R)(R-L+1)}{2}$ 里的“除以 2”用**费马逆元**

  $$
  2^{-1} \equiv 2^{M-2}\pmod{M}
  $$

  来做。
* 幂 $2^{\text{指数}}\pmod M$：可直接用快速幂。因为 $\gcd(2,M)=1$，指数可按 $M-1$ 约化（费马-欧拉定理）：

  $$
  2^k \equiv 2^{\,k\bmod (M-1)}\pmod M.
  $$

  因此在代码里把 $n-q$ 先 $\bmod (M-1)$ 再做快速幂即可（能减小幂运算位数）。

---

## 6. 复杂度分析

* 整除分块产生 $K=O(\sqrt n)$ 个块。
* 每块做一次快速幂（指数已模 $M-1$ 后，位数仅约 31 位）与常数次模乘加。
* **时间复杂度**：$O\!\big(\sqrt n\cdot \log M\big)$。
* **空间复杂度**：$O(1)$。

对 $n=10^{14}$ 完全可在普通电脑上 1 分钟内跑完。

---

## 7. 参考实现

> 这版刻意**不**做“增量幂 + popcount”的微优化，幂次全部用“普通快速幂”，更直观易读；模除法用费马逆元。

```cpp
#include <bits/stdc++.h>
using namespace std;
using LL = long long;
using ULL = unsigned long long;

/* --- 常用模运算 --- */
static inline LL addmod(LL a, LL b, LL mod){
    a += b; if (a >= mod) a -= mod; return a;
}
static inline LL submod(LL a, LL b, LL mod){
    a -= b; if (a < 0) a += mod; return a;
}
static inline LL mulmod(LL a, LL b, LL mod){
    // 防溢出：用 __int128 做乘法再取模
    return (LL)((__int128)a * b % mod);
}

/* --- 快速幂：a^e mod mod --- */
LL powmod(LL a, unsigned long long e, LL mod){
    LL r = 1 % mod;
    a %= mod;
    while (e){
        if (e & 1ULL) r = mulmod(r, a, mod);
        a = mulmod(a, a, mod);
        e >>= 1ULL;
    }
    return r;
}

/* --- 等差和 sum_{x=L}^R x (mod mod)
   使用 (L+R)*(R-L+1)/2，除以 2 用费马逆元 inv2 --- */
inline LL sum_range(ULL L, ULL R, LL mod, LL inv2){
    if (L > R) return 0;
    LL a = (LL)((L + R) % (ULL)mod);        // (L+R) mod M
    LL b = (LL)((R - L + 1) % (ULL)mod);    // (R-L+1) mod M
    LL res = mulmod(mulmod(a, b, mod), inv2, mod);
    return res;
}

void solve() {
    const LL MOD = 1234567891LL;    // 素数
    const LL PHI = MOD - 1;         // 对 2^k，可将 k 先模 (MOD-1)
    // 2 的费马逆元：2^(MOD-2) ≡ 2^{-1} (mod MOD)
    const LL inv2 = powmod(2 % MOD, PHI - 1, MOD);

    // 目标 n，可改成 10 做样例校验
    const ULL n_target = 100000000000000ULL; // 1e14

    // 计算 S(n) 的主过程
    auto compute_S = [&](ULL n)->LL{
        // --- A 项：2^(n-1) * n(n+1)/2 ---
        // 指数先模 PHI，减少 powmod 的位数（可选）
        ULL expA = (n - 1) % (ULL)PHI;
        LL two_n_1 = powmod(2, expA, MOD);
        LL Tn = sum_range(1, n, MOD, inv2); // n(n+1)/2 (mod MOD)
        LL A = mulmod(two_n_1, Tn, MOD);

        // --- B 项：整除分块 ---
        // B = sum over blocks [L..R]:
        //     2^(n - q) * sum_{x=L}^R x
        LL B = 0;
        for (ULL L = 1; L <= n; ){
            ULL q = n / L;          // 当前块对应的 floor(n/x) 的值
            ULL R = n / q;          // 最大右端点，保证 x∈[L..R] 时 floor(n/x)=q

            // 幂：2^(n - q)
            // 为了稳妥且更快，指数先 mod (MOD-1)
            ULL expB = ((n % (ULL)PHI) + (ULL)PHI - (q % (ULL)PHI)) % (ULL)PHI;
            LL p = powmod(2, expB, MOD);

            // 段和 sum_{x=L}^R x
            LL seg = sum_range(L, R, MOD, inv2);

            // 累加到 B
            B = addmod(B, mulmod(p, seg, MOD), MOD);

            L = R + 1;              // 下一块
        }

        // 最终结果：S = A - B
        LL S = submod(A, B, MOD);
        return S;
    };

    // 计时
    auto t0 = chrono::high_resolution_clock::now();

    // 小样例自检：S(10) 应为 4927
    LL S10 = compute_S(10ULL);

    // 计算目标：S(1e14) mod MOD
    LL Sans = compute_S(n_target);

    auto t1 = chrono::high_resolution_clock::now();
    double secs = chrono::duration<double>(t1 - t0).count();

    // 输出
    cout << "S(10) = " << S10 << " (expected 4927)\n";
    cout << "S(1e14) mod 1234567891 = " << Sans << "\n";
    cout << fixed << setprecision(3);
    cout << "Time = " << secs << " s\n";
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T = 1;
    while (T--) {
        solve();
    }
    return 0;
}
```
