---
title: PE202
date: 2025-6-6 15:41:44
mathjax: true
tags:
  - PE
  - Math
categories:
  - Project Euler
---

## 题目描述

三面镜子组成正三角形，镜面朝内。
激光束从顶点 $C$ 透过极小缝隙射入，在内部恰好 **反射 $k$ 次** 后仍从同一顶点射出。问不同路径条数（正向、反向算两条）。

已知

- $k=11$ 时答案为 2；
- $k=1\,000\,001$ 时答案为 80 840。

<!-- more -->

## 几何建模

1. **展开思路**
   把正三角形沿其三条边反射、再沿新边继续反射……会得到一张由全等正三角形铺满的平面（60° 平行镶嵌）。
    - 原三角形顶点 $A,B,C$ 被复制成无限个网格顶点。

    - 激光在原三角形内每 **反射一次**，在平铺里就 **穿过一条网格边**；于是“反射 $k$ 次”⇔“直线段跨 $k$ 条网格边”。

![imageTitle](/images/pe202.png)

2. **结果**
   展开后得到一张 60° 的正三角镶嵌；原三角形三个顶点在镶嵌中无限复制。

3. **反射次数与“跨边数”**
   设直线从复制的 $C_0$ 走到 $C_1$，记向量为 $(p,q)$。
   它与三族平行线（$x=\text{常}$、$y=\text{常}$、$x+y=\text{常}$）交点数分别为 $q,p,p+q$。扣掉两端重数 3 得

$$
k=2(p+q)-3, \qquad
m:=p+q=\frac{k+3}{2}.
$$

### 证明结论

取两基向量

$$
\mathbf{e}_x=(1,0),\qquad 
\mathbf{e}_y=\Bigl(\tfrac12,\tfrac{\sqrt3}{2}\Bigr)
$$

（60°角），则任一镶嵌顶点可写成整数对 $(x,y)\in\Bbb Z^2$。
三族网格边分别平行于

$$
x=\text{常数},\; y=\text{常数},\; x+y=\text{常数}.
$$

### 推导

* 取原三角形一边水平，另一边 60°。
* 每次拼贴只在 $\mathbf{e}_x$、$\mathbf{e}_y$、$\mathbf{e}_x-\mathbf{e}_y$ 三方向平移，所以“坐标整数化”。
* 于是三族平行线写成上式。

---

##  用向量 $(p,q)$ 描述“起点 $C$ → 终点 $C'$ 的直线”

### 结论

设直线从 $(0,0)$ 走到 $(p,q)$（不妨 $p,q>0$），则它与三族平行线相交

$$
\text{族1: }p,\quad
\text{族2: }q,\quad
\text{族3: }p+q
$$

次。把三端点的 3 次重复扣掉，**跨过网格边总数**是

$$
k =\bigl[(p+q)+p+q\bigr]-3 = 2(p+q)-3.
$$

### 详细推导

| 平行线族 | 方程                         | 在 0 与终点两侧共有几条线？ | 与直线交多少次？ |
| ---- | -------------------------- | --------------- | -------- |
| 1    | $x=n,\;n=0,1,\dots ,p$     | $p+1$ 条         | $p$ 次    |
| 2    | $y=n,\;n=0,1,\dots ,q$     | $q+1$ 条         | $q$ 次    |
| 3    | $x+y=n,\;n=0,1,\dots ,p+q$ | $p+q+1$ 条       | $p+q$ 次  |

把三列求和得 $p + q + p + q + p + q = 3(p+q)$。
然而在两端点 $(0,0)$、$(p,q)$ 同时被三族各记一次，共“多算了” 3 次，所以真实穿边数

$$
k = 3(p+q) - 3 = 2(p+q)-3.
$$

---

## 颜色分类与闭合条件

- 给全平面三角格 3-着色：
  $\text{色}(x,y)\equiv x-y\pmod3$。
- 原顶点 $C$ 定为 **0 色**。
- 要回到 $C$ 色 ⇒
  $p-q\equiv0\pmod3\Rightarrow p\equiv q\pmod3$。
  令

$$
s := 2m\bmod3\in\{1,2\},
\qquad\Longrightarrow\qquad
p\equiv s\pmod3.
$$

（因 $m\not\equiv0\pmod3$ ⇒ $s\neq0$。）

---

## 避免撞顶点：互素条件

直线段不能碰到除两端外的网格顶点 ⇔

$$
\gcd(p,q)=1
\quad\Longleftrightarrow\quad
\gcd(p,m)=1
\quad(\text{因 }q=m-p).
$$

---

## 几何 → 数论：把路径等价成整数计数<a name="几何–数论把路径等价成整数计数"></a>

合法路径 $(p,q)$ 与下列集合一一对应

$$
\mathcal S(m)=\Bigl\{
\;1\le p<m\ :\ p\equiv s\pmod3,\ \gcd(p,m)=1
\Bigr\}.
$$

记

$$
N(m):=|\mathcal S(m)|,
$$

则题目答案（含正、反向）就是 **$N(m)$**。

---

## 莫比乌斯反演计数

### 直线 $x+y=n$ 上 C 色点数 $F(n)$

沿该直线每走 3 格颜色循环一次，故

$$
F(n)=
\frac{n-G(n)}{3},
\qquad
G(n)=
\begin{cases}
+1,& n\equiv1\pmod3,\\[2pt]
-1,& n\equiv2\pmod3,\\[2pt]
0,& 3\mid n.
\end{cases}
$$

### “可见” C 点数 $f(n)$ 与 $F$ 的关系

设

$$
f(n)=\#\bigl\{(x,y):x+y=n,\ \gcd(x,y)=1,\ C\text{ 色}\bigr\}.
$$

对 $(x,y)$ 取 $d=\gcd(x,y)$，缩小得 $(u,v)=(x/d,y/d)$，落在直线 $x+y=n/d$。
于是有

$$
\boxed{F(n)=\sum_{d\mid n}f(d)}\tag{6.1}
$$

### 莫比乌斯反演：$f(n)=\dfrac{\varphi(n)-g(n)}{3}$

施行反演：

$$
\begin{aligned}
f(n)
&=\sum_{d\mid n}\mu\!\Bigl(\frac{n}{d}\Bigr)F(d)  \\[4pt]
&=\frac13\Bigl(
      \underbrace{\sum_{d\mid n}\mu\!\Bigl(\frac{n}{d}\Bigr)d}_{\varphi(n)}
      -\underbrace{\sum_{d\mid n}\mu\!\Bigl(\frac{n}{d}\Bigr)G(d)}_{g(n)}
    \Bigr).
\end{aligned}\tag{6.2}
$$

得到

$$
\boxed{f(n)=\dfrac{\varphi(n)-g(n)}{3}}.\tag{6.3}
$$

####  为什么

$$
\sum_{d\mid n}\mu\!\Bigl(\frac{n}{d}\Bigr)\,d
=\varphi(n)
$$

#### 记号与定义

* **恒等函数**　$I(n)=n$。
* **欧拉函数**　$\displaystyle\varphi(n)=n\!\!\prod_{p\mid n}\!\!\Bigl(1-\tfrac1p\Bigr)$。
* **莫比乌斯函数** $\mu(n)$。
* **Dirichlet 卷积** $(f* g)(n)=\displaystyle\sum_{d\mid n}f(d)\,g\!\bigl(\tfrac{n}{d}\bigr)$。

#### “$\mu$ 是卷积逆元”

$$
\mathbf1* \mu = \varepsilon,
\quad
\varepsilon(1)=1,\; \varepsilon(n>1)=0.
$$

#### 欧拉函数的卷积表达式

把 $\varphi$ 写成

$$
\varphi = I * (\mu * \mathbf1)
  = (I*\mu)*\mathbf1
  = J*\mathbf1,
$$

其中

$$
J(n)=\sum_{d\mid n} \mu(d)\,I\!\Bigl(\frac{n}{d}\Bigr)
   =\sum_{d\mid n} \mu(d)\,\frac{n}{d}
   =n\sum_{d\mid n}\frac{\mu(d)}{d}
   =n\!\!\!\!\!\!\prod_{p\mid n}\!\!\Bigl(1-\frac1{p}\Bigr).
$$

但右端正是欧拉函数的经典乘积式，所以

$$
J(n)=\varphi(n)\quad\Longrightarrow\quad
\sum_{d\mid n}\mu\!\Bigl(\frac{n}{d}\Bigr)\,d=\varphi(n).
$$

> **简化记法**
> 令卷积符号方向与分母相对调即可得到我们文中用的
> $\displaystyle\sum_{d\mid n}\mu\!\bigl(\frac{n}{d}\bigr)d$.

---


### 分析 $g(n)$

下面把 **$g(n)=\displaystyle\sum_{d\mid n}\mu\!\Bigl(\frac{n}{d}\Bigr)G(d)$**
这一项的 **完整推导 + 计算方法** 拆成四步：

| 步骤 | 要点                                 | 结论 / 公式                                                                                                                             |
| -- | ---------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------- |
| ①  | 明确 $G$、$\mu$ 的性质                   | 两个都是**完全乘法函数**                                                                                                                      |
| ②  | 利用完全乘法性，先求 **质数幂** $g(p^{\alpha})$ | 只需看 1、$p$、$p^{\alpha}$ 三个因子                                                                                                         |
| ③  | 把结果分类整理                            | <br>• 若 $p\equiv1\pmod3\Rightarrow g(p^{\alpha})=0$；<br>• 若 $p\equiv2\pmod3$ 或 $p=2\Rightarrow g(p^{\alpha}) = G(p^{\alpha})\cdot2$ |
| ④  | 乘法扩散到一般 $n$                        | <br>• **存在** $p\equiv1\pmod3\Rightarrow g(n)=0$<br>• **不存在** 这样的质因子 ⇒ $g(n)=G(n)\,2^{r}$，$r=$ 不同质因子个数                               |

下面按此顺序逐条展开。

---

####  $G$ 与 $\mu$ 都是完全乘法函数

* **$\mu$**（莫比乌斯函数）：

  $$
    \mu(ab)=\mu(a)\mu(b)\quad(\gcd(a,b)=1).
  $$
* **$G$** 的定义：

  $$
    G(n)=
    \begin{cases}
      +1,& n\equiv1\pmod3;\\
      -1,& n\equiv2\pmod3;\\
      {\ }0,& 3\mid n,
    \end{cases}
  $$

  也是完全乘法的（因为取值只由 $n\bmod3$ 决定；两数互 prime 时模 3 同余值相乘 → 模 3 同余的积）。

**完全乘法函数的狄利克雷卷积**仍是完全乘法，所以

$$
g=\mu*G\quad\Longrightarrow\quad g\text{ 亦完全乘法}.
$$

因此 **只要算清 $g(p^{\alpha})$，就能乘法扩张到任意 $n$**。

---

####  计算单质数幂 $g(p^{\alpha})$

公式

$$
g(p^{\alpha})
=\sum_{d\mid p^{\alpha}}\mu\!\Bigl(\frac{p^{\alpha}}{d}\Bigr)\,G(d).
$$

> **非零的 $\mu$** 只可能在
>
> $$
>   p^{\alpha}/d = 1\quad\text{或}\quad p
> $$
>
> （因为再带平方因子就让 $\mu=0$）。
> 因此
>
> $$
> g(p^{\alpha})
> = \mu(p)G(p^{\alpha-1}) + \mu(1)G(p^{\alpha})
> = -\,G(p^{\alpha-1}) \;+\; G(p^{\alpha}).
> $$

---

####  分类讨论（看 $p\bmod3$）

##### 若 $p\equiv1\pmod3$

* 所有幂 $p^{\beta}\equiv1\pmod3$，故
  $G(p^{\alpha-1}) = G(p^{\alpha}) = +1$。
* 代入 (\*)：

  $$
    g(p^{\alpha}) = -1 + 1 = 0.
  $$

#####  若 $p\equiv2\pmod3$ 或 $p=2$

* 幂次奇偶交替：

  $$
    p^{\text{奇}}\equiv2,\quad p^{\text{偶}}\equiv1\pmod3.
  $$

  因而

  $$
    G(p^{\alpha}) =
    \begin{cases}
      -1,&\alpha\text{ 奇};\\
      +1,&\alpha\text{ 偶}.
    \end{cases}
  $$
* 代入 (\*) 得

  $$
    g(p^{\alpha})
    = -\,G(p^{\alpha-1}) + G(p^{\alpha})
    = G(p^{\alpha}) - G(p^{\alpha-1})
    = \boxed{\,G(p^{\alpha})\cdot2\,}.
  $$

  （因为两项符号恰相反）

> **注意**：指数 $\alpha$ 并不影响绝对值，只决定 $G$ 的 ± 号。

---

####  乘法推到一般 $n$

设

$$
n=\prod_{i=1}^{r} p_i^{\alpha_i},\quad
\text{互素且 }p_1<\dots<p_r.
$$

利用完全乘法性

$$
g(n)=\prod_{i=1}^{r} g(p_i^{\alpha_i}).
$$

* **若存在** 某 $p_i\equiv1\pmod3$ ⇒ 该因子 $g(p_i^{\alpha_i})=0$ ⇒ **整积为 0**。
* **否则**（所有质因子 ≡2 或 =2）：

  $$
    g(n)=\prod_{i=1}^{r}\bigl(G(p_i^{\alpha_i})\cdot2\bigr)
         = \Bigl(\prod_{i=1}^{r}G(p_i^{\alpha_i})\Bigr)\,2^{r}
         = G(n)\,2^{r}.
  $$

  （乘法性保证 $\prod G = G(n)$）

> 这里的 $r$ 仅是“不同质因子数”，与各自指数 $\alpha_i$ 无关。

---

####  落地成一句“写代码级”判定

```text
若分解里出现 p ≡ 1 (mod 3) → g = 0
否则 → g = G(n) · 2^r
```

其中

$$
G(n)=
\begin{cases}
 +1,& n\equiv1\pmod3,\\
 -1,& n\equiv2\pmod3.
\end{cases}
$$

---

## 例子快速验证

| $n$        | 质因子       | 情形           | $G(n)$      | $r$ | $g(n)$          |
| ---------- | --------- | ------------ | ----------- | --- | --------------- |
| $7$        | 7≡1       | 含 $p\equiv1$ | –           | –   | 0               |
| $5$        | 5≡2       | 无 1-mod-3    | $-1$        | 1   | $-1\cdot2^1=-2$ |
| $5^2$      | 5≡2       | 无 1-mod-3    | $+1$ (25≡1) | 1   | $+1\cdot2=+2$   |
| $2\cdot11$ | 2≡2, 11≡2 | 无 1-mod-3    | $+1$        | 2   | $+1\cdot2^2=+4$ |
| $2\cdot13$ | 13≡1      | 含 1-mod-3    | –           | –   | 0               |

与前面公式及题目样例完全吻合。

---

### 结论再并一句

> **$g(n)$ 的值只有三种可能**
>
> $$
> g(n)=
> \begin{cases}
>    0,&\text{若 }n\text{ 含 }p\equiv1\pmod3;\\[4pt]
>    +\,2^{r},&\text{若 }n\not\equiv0\pmod3,\ n\equiv1\pmod3,\ \text{且无 }p\equiv1;\\[4pt]
>    -\,2^{r},&\text{若 }n\equiv2\pmod3,\ \text{且无 }p\equiv1.
> \end{cases}
> $$
>
> 算出 $g(n)$ 后，直接套
> $\displaystyle f(n)=\dfrac{\varphi(n)-g(n)}{3}$
> 就是激光路径总数。


## 计算

1. 计算

   $$
   m=\dfrac{k+3}{2},
   \quad s=2m\bmod3\in\{1,2\}.
   $$

2. 分解 $m$，得不同质因子个数 $r$。
3. **若存在** $p\equiv1\pmod3$：
   $g(m)=0$。
   否则
   $g(m)=G(m)\,2^{r}$。
4. 欧拉函数
   $\displaystyle\varphi(m)=m\prod_{p\mid m}(1-\tfrac1p)$。
5. 答案

   $$
     N(k)=f(m)=\frac{\varphi(m)-g(m)}{3}.
   $$

---

## 样例验证

| 反射次数 $k$   | $m=\tfrac{k+3}{2}$ | 质因子                       | $r$ | $\varphi(m)$  | $g(m)$         | $N(k)$                 |
| -------------- | ------------------ | ---------------------------- | --- | ------------- | -------------- | ---------------------- |
| 11             | 7                  | 7 (≡1)                       | 1   | 6             | 0              | $(6-0)/3=2$            |
| 1 000 001      | 500 002            | 2·53²·89 (皆 ≡2)             | 3   | 242 528       | $+1·2^{3}=8$   | $(242 528-8)/3=80 840$ |
| 12 017 639 147 | 6 008 819 575      | 5²·11·17·23·29·41·47 (皆 ≡2) | 7   | 3 627 007 872 | $+1·2^{7}=128$ | 1 209 002 624          |

与题目给出的三个正确值 **完全一致**。

## 时间复杂度与实现要点<a name="时间复杂度与实现要点"></a>

| 步骤           | 复杂度                    | 说明                            |
| -------------- | ------------------------- | ------------------------------- |
| 因数分解 $m$   | ≈ $m^{1/4}$ (Pollard-Rho) | 64 bit 整数毫秒级               |
| 计算 $\varphi$ | $O(r)$                    | 质因子个数 ≤ 7                  |
| 计算 $g$       | $O(r)$                    | 仅需判断 $p\bmod3$              |
| 总计           | 极快                      | 可以轻松通过 $k\le10^{12}$ 级别 |

---

## 总结

1. **展开几何** → “直线穿格” 模型；
2. **三色着色 + 互素** → 把路径计数转化为
   $\displaystyle N(m)=\#\{1\le p<m:\ p\equiv s\pmod3,\ \gcd(p,m)=1\}$。
3. _计算_

   - $F(n)$：直线上所有 C 色点数
   - $f(n)$：可见 C 色点数
   - 莫比乌斯反演
     导出

   $$
     f(n)=\dfrac{\varphi(n)-g(n)}{3}.
   $$

4. **核心判定**

   $$
     g(n)=
     \begin{cases}
       0,&\exists\,p\equiv1\pmod3,\\
       G(n)\,2^{r},&\text{否则}.
     \end{cases}
   $$

## 代码

```py
from sympy import factorint, totient

def laser_paths(k: int) -> int:
    """
    计算光线从顶点 C 入射、反射 k 次后仍从 C 射出的不同路径条数。
    正向 / 反向算两条。
    """
    m = (k + 3) // 2                        # 核心参数
    fac = factorint(m)                      # {p: α}
    
    r       = len(fac)                      # 不同质因子数
    has_p1  = any(p % 3 == 1 for p in fac)  # 是否含 p ≡ 1 (mod 3)
    
    # g(m)
    if has_p1:
        g = 0
    else:
        G = 1 if m % 3 == 1 else -1         # G(m) 的符号
        g = G * (1 << r)                    # 2^r
    
    # φ(m) 用 sympy.totient 一行搞定
    phi = totient(m)
    
    return (phi - g) // 3                   # f(m) = (φ - g)/3  即答案

# --- demo ---
for k in (11, 1_000_001, 12_017_639_147):
    print(f"k = {k:<12} → paths = {laser_paths(k)}")

```

```cpp
#include <bits/stdc++.h>
using namespace std;
using u64 = unsigned long long;
using u128 = __uint128_t;

// -------- Miller–Rabin (deterministic for 64-bit) ----------
u64 mod_mul(u64 a,u64 b,u64 m){ return (u128)a*b% m; }
u64 mod_pow(u64 a,u64 e,u64 m){
    u64 r=1;
    while(e){ if(e&1) r=mod_mul(r,a,m); a=mod_mul(a,a,m); e>>=1;}
    return r;
}
bool isPrime(u64 n){
    if(n<2) return 0;
    for(u64 p:{2,3,5,7,11,13,17,19,23,29,31,37}){ if(n%p==0) return n==p; }
    u64 d=n-1,s=0; while((d&1)==0){ d>>=1; ++s; }
    for(u64 a:{2,325,9375,28178,450775,9780504,1795265022}){
        if(a%n==0) continue;
        u64 x=mod_pow(a,d,n);
        if(x==1||x==n-1) continue;
        bool comp=true;
        for(u64 r=1;r<s;++r){
            x=mod_mul(x,x,n);
            if(x==n-1){ comp=false; break;}
        }
        if(comp) return false;
    }
    return true;
}

// -------- Pollard–Rho --------------
mt19937_64 rng((u64)chrono::steady_clock::now().time_since_epoch().count());
u64 rho(u64 n){
    if(n%2==0) return 2;
    while(true){
        u64 c=uniform_int_distribution<u64>(1,n-1)(rng);
        u64 x=uniform_int_distribution<u64>(0,n-1)(rng), y=x, d=1;
        auto f=[&](u64 v){ return (mod_mul(v,v,n)+c)%n; };
        while(d==1){
            x=f(x); y=f(f(y)); d=gcd<u64>(x>y?x-y:y-x,n);
        }
        if(d!=n) return d;
    }
}
void factor(u64 n, vector<u64>& fac){
    if(n==1) return;
    if(isPrime(n)){ fac.push_back(n); return; }
    u64 d=rho(n); factor(d,fac); factor(n/d,fac);
}

// -------- 核心函数 --------------
unsigned long long solve(unsigned long long k){
    unsigned long long m=(k+3)/2;

    // 分解
    vector<u64> fac;
    factor(m,fac);
    sort(fac.begin(),fac.end());
    fac.erase(unique(fac.begin(),fac.end()),fac.end()); // 只要不同质因子
    int r=fac.size();

    // φ(m)
    unsigned long long phi=m;
    for(u64 p:fac) phi=phi/p*(p-1);

    // g(m)
    bool has1=false;
    for(u64 p:fac) if(p%3==1) has1=true;
    long long g;
    if(has1) g=0;
    else{
        long long G = (m%3==1? +1 : -1);
        g = G * (1LL<<r);          // 2^r  (r ≤ 7 here)
    }

    return (phi - g)/3;
}

// -------- Demo --------
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    vector<unsigned long long> ks={
        11ULL, 1000001ULL, 12017639147ULL
    };
    for(auto k:ks){
        cout<<"k="<<k<<"  paths="<<solve(k)<<"\n";
    }
    return 0;
}

```