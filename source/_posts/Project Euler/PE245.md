---
title: PE245
date: 2025-12-10 11:41:27
mathjax: true
tags:
  - PE
  - Math
categories:
  - Project Euler
---

## 题目描述
题目大意：  
对于 $(n>1)$，定义
$$
C(n) = \frac{n - \varphi(n)}{n - 1}
$$
其中 $(\varphi)$ 是欧拉函数。$C(n)$ 被称为 **coresilience**。  
若 $C(n)$ 是一个**单位分数**（形如 $1/m$），我们称其 “很好”。  
本题要求：求出所有 **复合数** $1 < n \le 2\times 10^{11}$，使得
$$
C(n) = \frac{1}{m}
$$
对某个整数 $(m)$ 成立，求这些 $n$ 的**总和**。

<!-- more -->

## 1. 转换式子
由定义：

$$
C(n) = \frac{n - \varphi(n)}{n - 1}
$$

若 $C(n)$ 是单位分数，则存在整数 $m$ 使：

$$
\frac{n - \varphi(n)}{n - 1} = \frac{1}{m}
\quad\Longleftrightarrow\quad
m = \frac{n - 1}{n - \varphi(n)} \in \mathbb{Z}_{>0}
$$

## 2. 性质 1：$C(n)$ 是单位分数 ⇒ $n$ 是无平方因子数（square-free）

设 $p$ 是 $n$ 的一个质因子，令最大整数 $e$ 满足 $p^e \mid n$。写：

$$
n = p^e t, \quad \gcd(p,t) = 1
$$

欧拉函数分解：

$$
\varphi(n) = \varphi(p^e)\varphi(t) = p^{e-1}(p-1)\varphi(t)
$$

因此：

- $n$ 被 $p^e$ 整除；
- $\varphi(n)$ 被 $p^{e-1}$ 整除；
- 因而 **差** 也被 $p^{e-1}$ 整除：

$$
n - \varphi(n) \quad\text{被 } p^{e-1} \text{整除}
$$

记：

$$
n - \varphi(n) = p^{e-1} \cdot u
$$

又由于

$$
m = \frac{n - 1}{n - \varphi(n)} \in \mathbb{Z}
$$

分母的每个质因子都必须整除分子 $n-1$。特别地：

$$
p^{e-1} \mid (n - 1)
$$

但我们同时有：

$$
n \equiv 0 \pmod{p^{e-1}} \quad\Rightarrow\quad n-1 \equiv -1 \pmod{p^{e-1}}
$$

要让 $p^{e-1} \mid n-1$，只能 $p^{e-1} \mid 1$，于是：

$$
e-1 = 0 \Rightarrow e=1
$$

**结论：** 对每个质因子 $p$，指数都是 1，因此  
$n$ 是一个 **无平方因子数（square-free）**。

---

## 3. 性质 2：$n$ 必为奇数

如果 $n$ 是偶数：

- 则 $n-1$ 为奇数；
- 对所有 $n>2$，$\varphi(n)$ 一定是**偶数**（标准性质）；
- 因此 $n-\varphi(n)$ 为 “偶数 - 偶数 = 偶数”。

此时：

$$
m = \frac{n - 1}{n - \varphi(n)}
$$

- 分子：奇数；
- 分母：偶数；

偶数不可能整除奇数，所以 $m$ 不可能是整数。

**结论：** 满足条件的 $n$ 必为 **奇数**（不含质因子 $2$）。

---

## 4. 性质 3：$m$ 必为偶数

已知 $n$ 为奇数：

- $n-1$ 为偶数；
- $\varphi(n)$ 为偶数（$n>1$ 时的通用性质）；
- 因此 $n - \varphi(n)$ 是 “奇数 - 偶数 = 奇数”。

于是：

$$
m = \frac{n - 1}{n - \varphi(n)}
$$

- 分子：偶数；
- 分母：奇数；

偶数 / 奇数 若为整数，其奇偶性与分子相同，因此 $m$ 必为 **偶数**。

**结论：** 只需枚举 **偶数** $m$。

---

## 5. 结构化表示

知道 $n$ 是奇数且 square-free，可以写：

$$
n = p_1 p_2 \cdots p_k,\quad 3 \le p_1 < p_2 < \cdots < p_k
$$

此时

$$
\varphi(n) = \prod_{i=1}^{k} (p_i - 1)
$$

题解定义：

$$
x = \prod_{i=1}^{k-1} p_i,\quad y = \prod_{i=1}^{k-1} (p_i - 1),\quad p = p_k
$$

于是：

$$
n = x p,\quad
\varphi(n) = y (p - 1)
$$

代入

$$
m = \frac{n - 1}{n - \varphi(n)} = \frac{xp - 1}{xp - y(p-1)}
$$

分母展开：

$$
xp - y(p-1) = xp - yp + y = (x - y)p + y
$$

所以得到关键表达式：

$$
\boxed{m = \frac{xp - 1}{(x-y)p + y}}
$$

**在这里把 $m$ 看作关于 $p$ 的函数 $f(p)$。**

---

## 6. 单调性：$f(p) = \dfrac{xp-1}{(x-y)p + y}$ 是递增函数

设：

$$
f(p) = \frac{xp - 1}{(x-y)p + y} = \frac{Ap + B}{Cp + D}
$$

其中

- $A = x$
- $B = -1$
- $C = x - y$
- $D = y$

前面知道：

- $x = \prod_{i=1}^{k-1} p_i \ge 3$
- $y = \prod_{i=1}^{k-1} (p_i - 1) \ge 2$
- 且 $ \dfrac{x}{y} = \prod \dfrac{p_i}{p_i - 1} > 1 \Rightarrow x>y>0$

### 6.1 通用结论：$(Ap+B)/(Cp+D)$ 型函数的单调性

对于

$$
g(x)=\frac{Ax+B}{Cx+D}
$$

前提：$AD-BC\neq 0$，且在考虑区间内 $Cx+D \neq 0$。

计算导数：

$$
g'(x) = \frac{AD-BC}{(Cx+D)^2}
$$

因此只要 **在某个区间内 $Cx+D$ 不变号**（例如恒为正），那么：

- 若 $AD-BC>0$：$g(x)$ 在该区间严格单调递增；
- 若 $AD-BC<0$：$g(x)$ 在该区间严格单调递减。

这是一个可以直接记住的结论。

### 6.2 f(p)

计算：

$$
AD-BC = x\cdot y - (x-y)\cdot(-1) = xy + x - y = x(y+1)-y
$$

因为 $x\ge 3$、$y\ge 2$，显然：

$$
x(y+1)-y \ge 3(y+1)-y = 2y+3 > 0
$$

所以：

$$
AD-BC > 0
$$

再看分母：

$$
Cp + D = (x-y)p + y
$$

这里 $x-y>0,\ y>0,\ p>0$，因此对所有合法 $p$ 有

$$
(x-y)p + y > 0
$$

所以分母平方 $(Cp + D)^2 > 0$，不会变号。

于是：

> 在所有合法的 $p$ 取值上，  
> $f(p) = \dfrac{xp-1}{(x-y)p+y}$ 是 **严格单调递增** 的。

---

## 7. 用单调性得到m的枚举区间

有了单调性之后：

- 随着 $p$ 从某个下界 $p_{\min}$ 增大到上界 $p_{\max}$（由质数性与 $n\le N$ 限制），
- $m = f(p)$ 也从 $f(p_{\min})$ 单调地走到 $f(p_{\max})$。

因此

$$
m_{\min} = \left\lceil f(p_{\min}) \right\rceil,\quad
m_{\max} = \left\lfloor f(p_{\max}) \right\rfloor
$$

枚举整数 $m$ 只需要在这 **非常窄的区间** 内进行, 只需枚举所有 **偶数** $m\in [m_{\min}, m_{\max}]$。

---

## 8. 由m反推p

我们有：

$$
m = \frac{xp-1}{(x-y)p + y}
$$

解这个关于 $p$ 的方程：

因此：

$$
\boxed{p = \frac{1 + my}{x - m(x-y)}}
$$

只要：

1. $(1 + my) \% (x - m(x-y)) == 0$ ⇒ $p$ 是整数；
2. $p$是质数；

则 $(n = x\cdot p)$ 即为一个满足 $(C(n)=1/m)$ 的解，把它加到答案总和中。

---


## AC code
```cpp
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;

const ll N = 200000000000LL;
const int M = sqrt(N) + 4;

int pr[M / 10 + 1000], m = 0;
bool vis[M + 4];
ll ans = 0;

// 整数平方根: floor(sqrt(n))
ll int_sqrt(ll n) {
    if (n <= 0) return 0;
    long double x = sqrt((long double)n);
    ll r = (ll)x;
    while ((__int128)r * r > n) --r;
    while ((__int128)(r + 1) * (r + 1) <= n) ++r;
    return r;
}

// 快速乘 (使用 __int128 防止溢出)
ll mul_mod(ll a, ll b, ll mod) {
    return (ll)((__int128)a * b % mod);
}

// 快速幂 (mod)
ll pow_mod(ll a, ll d, ll mod) {
    ll r = 1 % mod;
    while (d) {
        if (d & 1) r = mul_mod(r, a, mod);
        a = mul_mod(a, a, mod);
        d >>= 1;
    }
    return r;
}

// Miller-Rabin 单次测试
bool miller_test(ll a, ll s, ll d, ll n) {
    ll x = pow_mod(a, d, n);
    if (x == 1 || x == n - 1) return true;
    for (int i = 1; i < s; ++i) {
        x = mul_mod(x, x, n);
        if (x == n - 1) return true;
    }
    return false;
}

// 判素数
bool is_prime(ll n) {
    if (n < 2) return false;
    static int small_primes[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 0};
    for (int i = 0; small_primes[i]; ++i) {
        if (n == small_primes[i]) return true;
        if (n % small_primes[i] == 0) return (n == small_primes[i]);
    }
    ll d = n - 1;
    int s = 0;
    while ((d & 1) == 0) {
        d >>= 1;
        ++s;
    }
    ll bases[] = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};
    for (ll a : bases) {
        if (a % n == 0) continue;
        if (!miller_test(a % n, s, d, n)) return false;
    }
    return true;
}

void dfs(int f, ll x, ll y) {
    ll p_max = int_sqrt(N / x);
    for (int i = f + 1; i <= m && pr[i] <= p_max; i++) {
        dfs(i, x * pr[i], y * (pr[i] - 1));
    }
    ll p = (f < m ? pr[f + 1] : pr[f] + 2);
    ll num = p * x - 1, den = p * (x - y) + y;
    ll kl = (num + den - 1) / den;
    if (kl % 2 == 1) kl += 1;
    num = (N / x) * x - 1;
    den = (N / x) * (x - y) + y;
    ll kr = num / den;
    for (ll k = kl; k <= kr; k += 2) {
        num = k * y + 1;
        den = x - k * (x - y);
        if (den == 0) continue;
        if (num % den == 0) {
            ll p2 = num / den;
            if (p2 > 1 && is_prime(p2))
                ans += x * p2;
        }
    }
}

int main() {
    // 开始计时
    auto t0 = chrono::high_resolution_clock::now();

    // 埃氏筛出所有 <= sqrt(N) 的素数
    for (int i = 2; i <= M; i++) {
        if (vis[i]) continue;
        pr[++m] = i;
        if (1LL * i * i > M) continue;
        for (ll j = 1LL * i * i; j <= M; j += i)
            vis[j] = 1;
    }
    for (int i = 2; i <= m; i++)
        dfs(i, pr[i], pr[i] - 1);

    printf("%lld\n", ans);

    // 结束计时
    auto t1 = chrono::high_resolution_clock::now();
    double elapsed = chrono::duration<double>(t1 - t0).count();
    printf("Time: %.6f s\n", elapsed);

    return 0;
}

```