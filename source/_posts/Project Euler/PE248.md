---
title: PE248
date: 2025-5-23 14:06:36
mathjax: true
tags:
- PE
- Math
categories:
- Project Euler
---


## 题目

The first number $n$ for which $\phi(n)=13!$ is $6227180929$.
Find the $150,000$<sup>th</sup> such number.

找到欧拉函数值是13!的第150000个数
<!-- more -->

## 题解

---

$$
\phi(n) = 13! = 6227020800
$$

的第 $150\,000$ 个最小的正整数 $n$。
由于欧拉函数不是单调的，不能直接逆推，因此必须通过构造所有满足 $\phi(n) = 6227020800$ 的数，然后排序取第 150000 个。

---

## 核心思路

### 1. 分析：$\phi(n) = \phi(p_1^{e_1}) \times \phi(p_2^{e_2}) \times \dots$

欧拉函数是 **积性函数**，对所有互素的因子满足：

$$\phi(p^e) = p^e - p^{e-1} = p^{e-1} \cdot \left(p - 1\right)$$

所以:

$$\phi(n) = \prod_i p_i^{e_i-1} \cdot \left(p - 1 \right)$$


---

## 逐步解释

---

### 第 0 步：预设和基础定义

```cpp
const ull M = 6227020800ULL;  // 13!
const int K = 150000;         // 第 150000 个目标
```

目标是 $\phi(n) = M = 13!$，我们要找第 K 个这样的 $n$。

---

### 第 1 步：构造所有可能的素因子（包括大素数）

```cpp
vector<pair<ull, int>> factor = {
    {2, 10}, {3, 5}, {5, 2}, {7, 1}, {11, 1}, {13, 1}
};
```

这些是 $13!$ 的素因子。

然后我们生成所有正整数 $d$ 使得 $d \mid M$，并尝试 $p = d + 1$，因为：

> 若 $p$ 是素数，且 $\phi(p) = p-1\mid M$，那么 $p$ 是一个可能的因子。

```cpp
ull p = d + 1;
if (p > 13 && isPrime(p)) {
    primes.push_back(p);
}
```

这些大素数是将来构造候选 $n$ 的关键。

---

### 第 2 步：为每个素数构造「块」(block)

```cpp
vector<pair<ull, ull>> build_block(ull p) {
    vector<pair<ull, ull>> res = {{1, 1}};
    ull pk = p, phi = p - 1;
    while (phi <= M && M % phi == 0) {
        res.emplace_back(phi, pk);
        pk *= p;
        phi *= p;
    }
    return res;
}
```

举例来说，对于 $p=3$，你会得到：

* $(\phi(3^1), 3^1) = (2,3)$
* $(\phi(3^2), 3^2) = (6,9)$
* $(\phi(3^3), 3^3) = (18,27)$
* 等等，只要 $\phi(p^k)\mid M$

---

### 第 3 步：合并所有 blocks，构造所有 $(\phi(n), n)$ 对

这一步是算法的关键。

```cpp
for (ull p : primes) {
    auto block = build_block(p);
    vector<pair<ull, ull>> next;

    for (auto& [phi1, n1] : current) {
        for (auto& [phi2, n2] : block) {
            ull phi_new = phi1 * phi2;
            if (M % phi_new != 0) continue; // φ(n) 必须整除 13!
            ull n_new = n1 * n2;
            next.emplace_back(phi_new, n_new);
        }
    }
    swap(current, next);
}
```

我们一开始只有 $(1,1)$，然后不断将它与每个素数的所有幂次组合合并。并且：

✅ **只保留能整除 $M$ 的 $\phi$**，否则不可能组合出 $\phi(n)=M$。

这样最终 `current` 中包含了所有可能组合出来的合法 $(\phi(n), n)$。

---

### 第 4 步：筛选出 $\phi(n)=M$，排序取第 K 个

```cpp
for (auto& [phi, n] : current) {
    if (phi == M) {
        results.push_back(n);
    }
}
sort(results.begin(), results.end());
```

最后我们从中筛选出所有 $\phi(n)=13!$ 的 $n$，并排序，取出第 K 个：

```cpp
if (results.size() >= K) {
    cout << "第 " << K << " 个 n 是: " << results[K - 1] << "\n";
}
```

---

## 总结关键点

| 步骤                              | 目的                      |
| ------------------------------- | ----------------------- |
| 构造约数 $d$ 得到可能的大素数 $p=d+1$       | 确保不会漏掉构造 $\phi(n)$ 的质因子 |
| 为每个素数构造块 $(\phi(p^k), p^k)$     | 利用欧拉函数积性结构              |
| 合并块，仅保留 $\phi\mid M$            | 避免爆炸增长并保证合法性            |
| 最终筛选 $\phi(n)=M$，排序取第 $K$ 个 $n$ | 得到目标解                   |

---


## 完整代码

```
#include <bits/stdc++.h>
using namespace std;
#ifdef LOCAL
#include "C:\zwl\files\docs\debug.h"
#else
#define debug(...) 42
#endif
using ull = unsigned long long;
const ull M = 6227020800ULL;  // 13!
const int K = 150000;

// 快速乘和快速幂
ull modmul(ull a, ull b, ull mod) {
    __uint128_t t = (__uint128_t)a * b;
    return t % mod;
}
ull modpow(ull a, ull e, ull mod) {
    ull res = 1;
    while (e) {
        if (e & 1)
            res = modmul(res, a, mod);
        a = modmul(a, a, mod);
        e >>= 1;
    }
    return res;
}

// Miller-Rabin 判断素数
bool isPrime(ull n) {
    if (n < 2)
        return false;
    for (ull p : {2, 3, 5, 7, 11, 13, 17, 19, 23}) {
        if (n % p == 0)
            return n == p;
    }
    ull d = n - 1, s = 0;
    while ((d & 1) == 0)
        d >>= 1, ++s;
    for (ull a : {2, 3, 5, 7, 11}) {
        if (a >= n)
            break;
        ull x = modpow(a, d, n);
        if (x == 1 || x == n - 1)
            continue;
        bool composite = true;
        for (int r = 1; r < s; ++r) {
            x = modmul(x, x, n);
            if (x == n - 1) {
                composite = false;
                break;
            }
        }
        if (composite)
            return false;
    }
    return true;
}

// 13! 的素因子分解
vector<pair<ull, int>> factor = {
    {2, 10},
    {3, 5},
    {5, 2},
    {7, 1},
    {11, 1},
    {13, 1}};

// 所有约数
void generate_divisors(int idx, ull cur, vector<ull>& divisors) {
    if (idx == factor.size()) {
        divisors.push_back(cur);
        return;
    }
    for (int i = 0; i <= factor[idx].second; ++i) {
        generate_divisors(idx + 1, cur, divisors);
        cur *= factor[idx].first;
    }
}

// 为素数构造块 [(phi(p^k), p^k)]
vector<pair<ull, ull>> build_block(ull p) {
    vector<pair<ull, ull>> res = {{1, 1}};
    ull pk = p, phi = p - 1;
    while (phi <= M && M % phi == 0) {
        res.emplace_back(phi, pk);
        if (pk > M / p)
            break;
        pk *= p;
        phi *= p;
    }
    return res;
}

int main() {
    auto start_time = std::chrono::high_resolution_clock::now();
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    // 1. 枚举素数集合
    vector<ull> primes = {2, 3, 5, 7, 11, 13};
    vector<ull> divisors;
    generate_divisors(0, 1, divisors);
    for (ull d : divisors) {
        ull p = d + 1;
        if (p > 13 && isPrime(p)) {
            primes.push_back(p);
        }
    }
    sort(primes.begin(), primes.end());

    // 2. 初始化状态
    vector<pair<ull, ull>> current = {{1, 1}};

    // 3. 合并所有 prime blocks，只保留 phi 整除 M 的项
    for (ull p : primes) {
        auto block = build_block(p);
        vector<pair<ull, ull>> next;

        for (auto& [phi1, n1] : current) {
            for (auto& [phi2, n2] : block) {
                ull phi_new = phi1 * phi2;
                if (M % phi_new != 0)
                    continue;
                ull n_new = n1 * n2;
                next.emplace_back(phi_new, n_new);
            }
        }
        swap(current, next);
    }

    // 4. 筛选 φ(n)=M
    vector<ull> results;
    for (auto& [phi, n] : current) {
        if (phi == M) {
            results.push_back(n);
        }
    }

    sort(results.begin(), results.end());
    if (results.size() >= K) {
        cout << "第 " << K << " 个 n 是: " << results[K - 1] << "\n";
    } else {
        cout << "找不到足够的解，只有 " << results.size() << " 个\n";
    }

    auto end_time = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time).count();
    std::cout << "代码执行时间: " << duration << " 毫秒" << std::endl;
    return 0;
}

```
