---
title: PE281
date: 2025-12-11 17:18:10
mathjax: true
tags:
  - PE
  - Math
categories:
  - Project Euler
---

## 题目描述
**题目背景**：
你有一个圆形的披萨，被切成了 $m \times n$ 块大小相等的扇形。你有 $m$ 种不同的配料（颜色），要求每种配料恰好使用 $n$ 次（即每种颜色涂 $n$ 块）。

**规则**：
- **旋转**后的披萨被视为同一种方案（例如，披萨转了30度，看起来和原来一样，就算同一种
- **翻转**（镜像）后的披萨被视为**不同**的方案

**定义** $f(m, n)$：满足上述条件的涂色方案数。
**目标**：计算所有满足 $f(m, n) \le 10^{15}$ 的 $f(m, n)$ 的总和。

**样例解析**：
- $f(2, 1) = 1$：2种颜色，每种1块。共2块。方案只有 [A, B]（顺时针）。旋转后 [B, A] 是同一种。翻转也是它自己。实际上只有1种相对位置关系（对面）。
- $f(3, 1) = 2$：3种颜色，每种1块。共3块。方案有 [A, B, C] 和 [A, C, B]。这两种无法通过旋转互相得到（一个是顺时针，一个是逆时针），所以是2种。


<!-- more -->

## 解题思路

这个问题本质上是在求**在循环群作用下的轨道数量**。

### 核心工具：Burnside引理
公式为：
$$ N = \frac{1}{|G|} \sum_{g \in G} |X^g| $$
其中：
- $N$ 是本质不同的方案数（即 $f(m, n)$）。
- $G$ 是作用在披萨切片上的置换群。因为只考虑旋转，这是一个阶为 $S = m \times n$ 的循环群。$|G| = mn$。
- $X$ 是所有不考虑旋转时的线性排列集合。
- $X^g$ 是被群元素 $g$（某种特定的旋转）作用后保持不变的方案集合。

### 公式推导

1.  **旋转分类**：
    披萨共有 $S = mn$ 块。对于每一个可能的旋转 $k$ ($1 \le k \le mn$)，它会将 $S$ 个位置分成 $d = \gcd(k, S)$ 个循环，每个循环的长度为 $S/d$。

2.  **不变性条件**：
    如果一个涂色方案在旋转 $k$ 下保持不变，那么在同一个循环内的所有切片必须涂相同的颜色。
    这意味着我们需要给这 $d$ 个循环涂色，而不是给 $S$ 个切片涂色。

3.  **颜色计数约束**：
    原题要求每种颜色恰好用 $n$ 次。
    在旋转 $k$ 的“压缩”视图中，我们有 $d$ 个“超级切片”（即循环）。如果我们给某个超级切片涂了颜色 $C$，那么在还原回完整披萨时，实际上消耗了 $S/d$ 个颜色 $C$ 的切片。
    假设我们在压缩视图中给 $c_i$ 个超级切片涂了第 $i$ 种颜色。
    那么总消耗为 $c_i \times (S/d) = n$。
    推出 $c_i = \frac{n}{mn/d} = \frac{n \cdot d}{mn} = \frac{d}{m}$。
    
    **关键结论**：
    - 只有当 $m$ 整除 $d$ 时，才存在有效的涂色方案（否则无法分配整数个超级切片给每种颜色）。
    - 如果 $m \mid d$，我们需要将 $d$ 个位置分配给 $m$ 种颜色，每种颜色恰好占 $d/m$ 个位置。

4.  **多项式系数**：
    在满足条件的情况下，涂色方案数即为多项式系数：
    $$ |X^k| = \frac{d!}{( (d/m)! )^m} $$

5.  **化简求和**：
    我们不需要遍历所有 $k=1 \dots mn$，而是遍历 $S=mn$ 的因子。
    令 $d = \gcd(k, mn)$。$d$ 必须是 $mn$ 的因子，且由上述推导，$d$ 必须是 $m$ 的倍数。
    满足 $\gcd(k, mn) = d$ 的 $k$ 的个数由欧拉函数 $\phi(mn/d)$ 给出。

    **最终公式**：
    $$ f(m, n) = \frac{1}{mn} \sum_{d \mid mn, \ m \mid d} \phi\left(\frac{mn}{d}\right) \frac{d!}{\left( (d/m)! \right)^m} $$


## 搜索范围分析
我们需要找出所有 $f(m, n) \le 10^{15}$。
- 当 $m$ 增大时，$f(m, n)$ 增长极快。
- 当 $n$ 增大时，$f(m, n)$ 增长极快。
- 即使是 $m=2$，当 $n \approx 27$ 时，$f(2, 27) \approx \frac{1}{54} \binom{54}{27} \approx 3 \times 10^{13}$，很快就会超限。
- 当 $n=1$ 时，$f(m, 1) = (m-1)!$。$18! \approx 6.4 \times 10^{15}$，所以 $m$ 最多到 18左右。
- 因此，我们可以直接用两层循环枚举 $m$ 和 $n$，一旦数值超过 $10^{15}$ 就停止内层循环。整个搜索空间非常小。


## AC code

```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <cmath>
#include <algorithm>
#include <chrono>

// 使用 unsigned __int128 防止中间计算溢出
// 题目要求结果 <= 10^15，求和后也不会超过 uint64 的范围，
// 但计算项的时候分子可能很大。
typedef unsigned __int128 u128;

// 辅助函数：计算最大公约数
u128 gcd(u128 a, u128 b) {
    while (b) {
        a %= b;
        std::swap(a, b);
    }
    return a;
}

// 辅助函数：计算欧拉函数 phi(n)
u128 phi(u128 n) {
    u128 result = n;
    for (u128 i = 2; i * i <= n; i++) {
        if (n % i == 0) {
            while (n % i == 0)
                n /= i;
            result -= result / i;
        }
    }
    if (n > 1)
        result -= result / n;
    return result;
}

// 辅助函数：计算组合数 C(n, k)
u128 nCr(long long n, long long k) {
    if (k < 0 || k > n) return 0;
    if (k == 0 || k == n) return 1;
    if (k > n / 2) k = n - k;
    
    u128 res = 1;
    for (long long i = 1; i <= k; ++i) {
        res = res * (n - i + 1) / i;
    }
    return res;
}

// 计算多项式系数: d! / ((k!)^m) 其中 k = d/m
// 这种形式等价于连续做组合数乘法:
// C(d, k) * C(d-k, k) * ... * C(k, k)
u128 multinomial_equal_parts(long long m, long long d) {
    long long k = d / m;
    u128 res = 1;
    long long current_d = d;
    for (int i = 0; i < m - 1; ++i) { // 最后一次是 C(k, k) = 1，可省略
        res *= nCr(current_d, k);
        current_d -= k;
    }
    return res;
}

int main() {
    auto start_time = std::chrono::high_resolution_clock::now();

    const u128 LIMIT = 1000000000000000ULL; // 10^15
    u128 total_sum = 0;

    // m 从 2 开始 (至少2种颜色)
    for (long long m = 2; ; ++m) {
        bool m_valid = false; // 标记对于当前的 m，是否存在至少一个 n 满足条件

        // n 从 1 开始
        for (long long n = 1; ; ++n) {
            long long total_slices = m * n;
            u128 orbit_sum = 0;

            // 遍历 total_slices 的因子 d
            // 优化：只遍历满足 m | d 的 d
            // d 是循环的个数
            for (long long d = m; d <= total_slices; d += m) {
                if (total_slices % d == 0) {
                    // d 必须是 total_slices 的因子，且是 m 的倍数
                    // 项 = phi(mn/d) * (d! / ((d/m)!)^m)
                    
                    u128 ways = multinomial_equal_parts(m, d);
                    u128 p = phi(total_slices / d);
                    
                    orbit_sum += ways * p;
                }
            }

            // Burnside 引理：除以群的大小
            u128 f_mn = orbit_sum / total_slices;

            if (f_mn <= LIMIT) {
                total_sum += f_mn;
                m_valid = true;
                // 可以取消注释查看具体的 f(m,n)
                // std::cout << "f(" << m << ", " << n << ") = " << (unsigned long long)f_mn << "\n";
            } else {
                // 因为 f(m, n) 随 n 单调递增，一旦超过 LIMIT，后续 n 都不需要计算
                break;
            }
        }

        // 如果对于 n=1 都不满足 (实际上 f(m,1) = (m-1)! )，则更大的 m 也不可能满足
        if (!m_valid) {
            break;
        }
    }

    auto end_time = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> elapsed = end_time - start_time;

    std::cout << "Total Sum: " << (unsigned long long)total_sum << std::endl;
    std::cout << "Time: " << elapsed.count() << " seconds." << std::endl;

    return 0;
}
```


## 关于化简求和部分的详细解释

好的，我们一步步来推导这个公式。这个过程是将 Burnside 引理从“遍历所有旋转操作”转化为“遍历循环数量（因子）”的过程，这是组合数学中处理旋转同构问题的标准优化技巧。

### 1. Burnside 引理的基础公式

首先，Burnside 引理告诉我们，不等价的着色方案数 $N$ 等于所有群元素（在这里就是旋转操作）作用下的“不动点”数量的平均值。

公式如下：
$$ N = \frac{1}{|G|} \sum_{g \in G} |X^g| $$

在我们的披萨问题中：
- **$G$**：是披萨的旋转群。披萨一共有 $S = m \times n$ 块。所以共有 $S$ 种旋转操作（转0格，转1格，...，转 $S-1$ 格）。
- **$|G|$**：群的大小就是 $S = mn$。
- **$g$**：代表第 $k$ 种旋转操作（即顺时针旋转 $k$ 个单位， $1 \le k \le mn$）。
- **$|X^g|$**：代表在旋转 $k$ 的作用下，保持外观不变的涂色方案总数。

所以，原始的基础公式是：
$$ f(m, n) = \frac{1}{mn} \sum_{k=1}^{mn} |X^{\text{rot}_k}| $$

---

### 2. 计算不动点数量 $|X^{\text{rot}_k}|$

要在旋转 $k$ 下保持不变，披萨上的颜色必须满足什么条件？

1.  **循环分解**：
    旋转 $k$ 个单位会将 $S = mn$ 个位置分成若干个独立的循环。
    根据群论性质，循环的个数由最大公约数决定：
    $$ \text{循环个数 } d = \gcd(k, mn) $$
    每个循环的长度为 $\frac{mn}{d}$。

2.  **颜色一致性**：
    如果一个方案旋转后不变，那么**同一个循环内的所有切片必须涂相同的颜色**。
    这把问题从“给 $mn$ 个切片涂色”简化为“给 $d$ 个循环涂色”。

3.  **数量限制检查**：
    题目要求每种颜色恰好使用 $n$ 次。
    假设我们给某个循环涂了颜色 $C$，因为这个循环包含 $\frac{mn}{d}$ 个切片，所以实际上消耗了 $\frac{mn}{d}$ 个颜色 $C$ 的份额。
    
    我们要把 $d$ 个循环分配给 $m$ 种颜色。假设第 $i$ 种颜色分配给了 $c_i$ 个循环，那么该颜色总共使用的切片数为：
    $$ c_i \times \frac{mn}{d} = n $$
    解得：
    $$ c_i = \frac{n \cdot d}{mn} = \frac{d}{m} $$
    
    **重要结论**：
    只有当 $c_i$ 是整数时，才存在合法的涂色方案。这意味着 **$d$ 必须能被 $m$ 整除** ($m \mid d$)。如果 $m$ 不能整除 $d$，则 $|X^{\text{rot}_k}| = 0$。

4.  **排列组合**：
    如果 $m \mid d$，我们需要将 $d$ 个位置（循环）分配给 $m$ 种颜色，每种颜色恰好占 $d/m$ 个位置。这是一个多项式系数问题：
    $$ |X^{\text{rot}_k}| = \frac{d!}{(d/m)! \cdot (d/m)! \cdots (d/m)!} = \frac{d!}{\left( (d/m)! \right)^m} $$

---

### 3. 化简求和过程 (从遍历 $k$ 到遍历 $d$)

我们现在的公式是：
$$ f(m, n) = \frac{1}{mn} \sum_{k=1}^{mn} \text{Value}(\gcd(k, mn)) $$
其中 $\text{Value}(d)$ 就是上面的组合数（如果 $m \mid d$）或 0。

直接遍历 $k$ 效率较低（虽然对于 $10^{15}$ 限制下的 $mn$ 来说其实也很快，但数学上不美观且不利于分析）。我们发现，对于很多不同的 $k$，它们的 $\gcd(k, mn)$ 是相同的。我们可以根据 GCD 的值 $d$ 来对项进行分组。

1.  **定义 $d$**：
    令 $d$ 为 $\gcd(k, mn)$ 的可能值。显然 $d$ 必须是 $mn$ 的因子。

2.  **统计频率**：
    对于 $mn$ 的某个因子 $d$，有多少个 $k \in \{1, \dots, mn\}$ 满足 $\gcd(k, mn) = d$ ？
    
    推导如下：
    $$ \gcd(k, mn) = d \iff \gcd(k/d, mn/d) = 1 $$
    令 $j = k/d$。因为 $1 \le k \le mn$，所以 $1 \le j \le mn/d$。
    问题转化为：在 $1$ 到 $mn/d$ 之间，有多少个整数 $j$ 与 $mn/d$ 互质？
    
    根据定义，这个数量正是欧拉函数 **$\phi(mn/d)$**。

3.  **重写求和公式**：
    我们将求和变量从 $k$ 变为 $mn$ 的因子 $d$。
    
    - 原来是：$\sum_{k=1}^{mn} (\dots)$
    - 现在变为：$\sum_{d | mn} (\text{满足该 GCD 的 k 的个数}) \times (\text{该 d 对应的不动点数量})$
    
    即：
    $$ \sum_{k=1}^{mn} |X^{\text{rot}_k}| = \sum_{d | mn} \phi\left(\frac{mn}{d}\right) \times |X^{\text{GcdIs}_d}| $$

4.  **加入 $m \mid d$ 的约束**：
    前面提到，只有当 $\gcd(k, mn) = d$ 且 $m \mid d$ 时，不动点数量才不为0。
    
    所以最终的求和只需要遍历那些 **既是 $mn$ 的因子，又是 $m$ 的倍数** 的 $d$。

### 4. 最终公式

将上述部分整合，得到最终代码中使用的公式：

$$ f(m, n) = \frac{1}{mn} \sum_{\substack{d \,|\, mn \\ m \,|\, d}} \phi\left(\frac{mn}{d}\right) \frac{d!}{\left( (d/m)! \right)^m} $$

**公式中各部分的含义总结：**
- $\frac{1}{mn}$：Burnside 引理中的除以群大小。
- $\sum$：遍历所有可能的循环个数 $d$。
- $\phi(\frac{mn}{d})$：有多少个旋转操作会产生恰好 $d$ 个循环。
- $\frac{d!}{\left( (d/m)! \right)^m}$：在有 $d$ 个循环的情况下，分配 $m$ 种颜色的方案数。