---
title: PE369
date: 2026-1-31 15:10:00
mathjax: true
tags:
  - PE
  - Math
categories:
  - Project Euler
---

## 题目描述

标准 52 张扑克牌（4 种花色 × 13 种点数）。若一组 4 张牌 **点数互不相同** 且 **花色互不相同**，则称该 4 张牌为 **Badugi**。

定义 $f(n)$：从 52 张牌中选出 $n$ 张的所有组合中，**至少包含一个 Badugi 子集**的方案数。题目给出样例：

- $\binom{52}{5}=2598960$
- 其中 $f(5)=514800$

求

$$
\sum_{n=4}^{13} f(n).
$$

<!-- more -->

## 解题思路

### 整体思路

先数补集 $g(n)$，把“含 Badugi”转成“最大匹配大小 $\le 3$”，从而避免直接枚举 4 张子集。接着把手牌建成“花色–点数”的二分图，Badugi 等价于覆盖 4 个花色的大小为 4 匹配。于是问题变成：在给定边集的情况下，是否能用若干点数形成覆盖指定花色集合的匹配。利用“同一点数在匹配中最多使用一次”的限制，维护 $F[mask]$ 表示当前可覆盖的花色集合。对 13 个点数逐层 DP，并同时统计已选牌数 $k$，就能得到每个 $n$ 的 $g(n)$，再由 $f(n)=\binom{52}{n}-g(n)$ 求出最终求和。

---

### 1. 补集定义 $g(n)$

直接数“包含 Badugi”的手牌很难，先数补集：

$$
\boxed{g(n)=\#\{H\subseteq \text{Deck}\mid |H|=n,\;H\text{ 中不存在任何 Badugi 子集}\}}
$$

那么

$$
\boxed{f(n)=\binom{52}{n}-g(n)}
$$

我们的目标就变成：对 $4\le n\le13$ 求 $g(n)$。

---

### 2. 二分图建模

把一手牌看成一个 **二分图**：

- 左边 4 个点：花色 $S=\{0,1,2,3\}$
- 右边 13 个点：点数 $R=\{A,2,\dots,K\}$
- 若手牌中包含“花色 $s$、点数 $r$”的牌，就连边 $(s,r)$

那么：

- 选 4 张 **花色互不相同、点数互不相同** 的牌
- 等价于图中存在一个 **大小为 4 的匹配**，覆盖全部 4 个花色

因此：

> 手牌中 **存在 Badugi**  
> $\Longleftrightarrow$ 该二分图存在 **大小为 4 的匹配**。

所以“没有 Badugi”就等价于：**最大匹配大小 $\le 3$**。这就是建模的核心好处。

---

### 3. 判定 DP

按 **点数**（13 层）逐层处理。对某个点数 $r$，你可以从 4 个花色里任选一个子集 $S$（共 $2^4=16$ 种），表示你是否把该点数下的某些花色牌放进手牌。

关键观察：

> 匹配里 **同一个点数最多只能用 1 张牌**（因为匹配右侧点数不能重复）。

因此定义布尔 DP：

$$
F[mask]=\text{是否能找到一个匹配，恰好覆盖花色集合 }mask
$$

- $mask\subseteq\{0,1,2,3\}$，共有 16 种
- 初始 $F[0]=\text{true}$

处理某一层点数，其可用花色集合为 $S$ 时：

- 可以 **不用**该点数：保留 $F$
- 也可以用该点数去匹配 **一个**花色 $u\in S$（只能一个）：

$$
F'[mask\cup\{u\}]\;|=\;F[mask],\quad u\in S\setminus mask
$$

最终若 $F[\{0,1,2,3\}]$ 为真，说明存在 Badugi。

---

### 4. 计数 DP

为了计数，用一个 16 位整数 `pat` 表示整个 $F$：

- `pat` 的第 $m$ 位为 1 ⇔ $F[m]=true$
- 总状态数 $2^{16}=65536$

定义：

$$
\text{dp}[k][pat] =\; \text{处理若干点数后，已选 }k\text{ 张牌且 }F\text{ 的形状为 }pat\text{ 的方案数}
$$

转移：对每个点数枚举 16 种 $S$：

- $k$ 增加 $|S|$
- `pat` 更新为 `trans[pat][S]`

预处理 `trans`：

- 对于每个旧的可达 $mask$（即 `pat` 中的 1 位）
- 只允许用当前点数 **扩展一个花色位**（不能扩展两次）

最终：

$$
\boxed{g(n)=\sum_{\text{pat 的第 }15\text{ 位为 }0} \text{dp}[n][pat]}
$$

（第 15 位表示 $mask=1111_2$ 是否可达；为 0 就表示没有 Badugi）

---

## 复杂度分析

- 预处理转移：$O(2^{16}\cdot 16\cdot 16\cdot 4)$  
  （枚举 `pat`、`S`、旧 `mask` 与 4 个花色）
- 主 DP：对 13 个点数层，每层枚举 $k\le 13$、$2^{16}$ 个 `pat` 与 16 个 `S`

$$
O(13\cdot 13\cdot 2^{16}\cdot 16) \approx 1.8\times 10^8
$$

- 空间复杂度：$O(13\cdot 2^{16})$（两层 DP）  
  另有转移表 $O(2^{16}\cdot 16)$，总内存几十 MB 以内


---

## AC code (C++)

```cpp
#include <bits/stdc++.h>
using namespace std;
using LL = long long;
using i128 = __int128_t;

LL C(int n, int k) {
    if (k < 0 || k > n) return 0;
    if (k > n - k) k = n - k;
    i128 r = 1;
    for (int i = 1; i <= k; i++) r = r * (n - k + i) / i;
    return (LL)r;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    auto st = chrono::high_resolution_clock::now();

    const int mx = 13;
    const int M = 1 << 16; // pat 状态数

    int pc[16];
    for (int s = 0; s < 16; s++) pc[s] = __builtin_popcount((unsigned)s);

    // 预处理 trans[pat][s]
    vector<vector<int>> tr(M, vector<int>(16, 0));
    for (int pat = 0; pat < M; pat++) {
        for (int s = 0; s < 16; s++) {
            int np = pat; // 不用该点数
            for (int m = 0; m < 16; m++) if ((pat >> m) & 1) {
                int fre = s & ((~m) & 15); // 可用花色
                for (int u = 0; u < 4; u++) if ((fre >> u) & 1) {
                    int nm = m | (1 << u);
                    np |= (1 << nm);
                }
            }
            tr[pat][s] = np;
        }
    }

    vector<vector<LL>> dp(mx + 1, vector<LL>(M, 0));
    vector<vector<LL>> ndp(mx + 1, vector<LL>(M, 0));
    dp[0][1] = 1; // 仅 F[0]=true

    for (int r = 0; r < 13; r++) {
        for (int k = 0; k <= mx; k++) fill(ndp[k].begin(), ndp[k].end(), 0);
        for (int k = 0; k <= mx; k++) {
            for (int pat = 0; pat < M; pat++) {
                LL cnt = dp[k][pat];
                if (!cnt) continue;
                for (int s = 0; s < 16; s++) {
                    int kk = k + pc[s];
                    if (kk > mx) continue;
                    int np = tr[pat][s];
                    ndp[kk][np] += cnt;
                }
            }
        }
        dp.swap(ndp);
    }

    LL ans = 0;
    for (int n = 4; n <= 13; n++) {
        LL gn = 0;
        for (int pat = 0; pat < M; pat++) {
            if (((pat >> 15) & 1) == 0) gn += dp[n][pat];
        }
        ans += C(52, n) - gn;
    }

    cout << ans << "\n";

    auto ed = chrono::high_resolution_clock::now();
    auto ms = chrono::duration_cast<chrono::milliseconds>(ed - st).count();
    cerr << "time: " << ms << " ms\n";
    return 0;
}
```
