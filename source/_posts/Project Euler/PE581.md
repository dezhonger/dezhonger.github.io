---
title: PE581
date: 2025-5-27 23:15:02
mathjax: true
tags:
- PE
- Math
categories:
- Project Euler
---

## 题目描述

一个正整数称为 **p-平滑数（p-smooth number）**，如果它的所有质因子都不大于 $p$。

记三角数序列为：

$$
T(n) = \frac{n(n+1)}{2}
$$

现在要求：

> 找出所有使得三角数 $T(n)$ 是 47-平滑数的下标 $n$，并计算这些 $n$ 的总和。
<!-- more -->
---

## 思路解析

### 1. 平滑性传递到因子

我们注意到：

$$
T(n) = \frac{n(n+1)}{2}
$$

由于 $ \gcd (n, n+1) = 1 $，如果 $ T(n) $ 是 47-平滑数，那么：

* $n$ 只能含素因子 $\le 47$
* $ n+1 $ 也只能含素因子 $\le 47$
* 除了 2 在分母中使用了一次，其他因子独立。

因此：

> 只要 $ n $ 和 $ n+1 $ 都是 47-平滑数，$T(n)$ 就是 47-平滑数。

这等价于寻找所有 **相邻的 47-平滑数对** $(k, k+1)$，然后将这些 $k$ 累加。

---

### 2. 枚举平滑数

47-平滑数是指只由以下质数组成的数：

```
[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]
```

形式为：

$$
2^a \cdot 3^b \cdot 5^c \cdots 47^o
$$

我们需要**按从小到大**枚举所有这类正整数，并找出其中相邻的对 $(k, k+1)$。

---

### 3. 如何高效枚举平滑数

我们使用以下方法：

* **最小堆（优先队列）**：保持当前最小的候选平滑数；
* **哈希集合**：用于避免重复加入堆。

#### 步骤如下：

1. 初始将 1 放入堆；
2. 每次弹出最小元素 `cur`；
3. 将 `cur × p`（对所有质因子 `p ≤ 47`）作为新候选入堆（未见过且不超上限）；
4. 记录前一个数 `last`，如果 `last + 1 == cur`，说明找到了一个相邻平滑对；
5. 把 `last` 加入答案。

---

### 4. 终止条件

根据 **Størmer 定理**，只有有限个相邻平滑对。因此我们只需设定一个合理的上界即可。

从已知资料（如 [OEIS](https://oeis.org/A117581)）得知：

> 最大的相关下标约为 $1.1 \times 10^{12}$。

所以程序可以安全地在堆顶超过该上限时终止。

---

## C++ 实现代码

```cpp
#include <bits/stdc++.h>
using namespace std;
using u64 = unsigned long long;

int main() {
    const u64 BOUND = 1200000000000ULL; // 稍微放宽上限更保险
    vector<u64> primes = {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47};

    priority_queue<u64, vector<u64>, greater<u64>> pq;
    unordered_set<u64> seen;
    pq.push(1);
    seen.insert(1);

    u64 last = 0;
    __int128 answer = 0;

    while (!pq.empty()) {
        u64 cur = pq.top(); pq.pop();
        if (cur > BOUND) break;

        if (last + 1 == cur) {
            answer += last;
        }
        last = cur;

        for (u64 p : primes) {
            __int128 nxt = (__int128)cur * p;
            if (nxt > BOUND) break;
            u64 vn = (u64)nxt;
            if (!seen.count(vn)) {
                seen.insert(vn);
                pq.push(vn);
            }
        }
    }

    // 输出 __int128 的结果
    string res;
    while (answer > 0) {
        res += '0' + (answer % 10);
        answer /= 10;
    }
    reverse(res.begin(), res.end());
    cout << res << endl;

    return 0;
}
```

---

## 最终结果

运行程序，得到最终答案为：

```

```

---

## 小结

| 项目    | 内容                             |
| ----- | ------------------------------ |
| 本质转换  | 三角数平滑性 ⇨ 相邻平滑数对                |
| 枚举方式  | 最小堆 + 哈希集合，按升序遍历所有 47-平滑数      |
| 正确性保障 | 使用 Størmer 定理保证枚举有限；设定安全上界确保终止 |
| 实现语言  | C++，用 `__int128` 处理大整数防止溢出     |
| 总结    | 一个非常典型的“数论 + 堆枚举 + 平滑数”的综合应用题  |

---
