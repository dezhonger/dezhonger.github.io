---
title: PE612
date: 2025-8-14 01:06:51
mathjax: true
tags:
  - PE
  - Math
categories:
  - Project Euler
---

## 题目描述

* 定义：两个十进制正整数，如果它们的十进制表示中**至少有一个相同的数字**，称为“朋友数”（friend numbers）。
  例：1123 和 3981 都含有数字 1，因此是朋友数。

* 令 $f(n)$：满足 $1\le p<q<n$ 且 $p,q$ 是朋友数的有序对数量。
  已知：$f(100)=1539$。

* 目标：计算

  $$
  f(10^{18})\ \bmod\ 1000267129.
  $$

---

<!-- more -->


## 🧠 总体思路

**把每个数出现过的数字集合编码为 10 位掩码**（从低位到高位依次表示数字 0–9 是否出现）。
两个数是朋友数 ⇔ 两个掩码按位与不为 0。

令 $N=n-1$（因为数从 1 到 $n-1$），总对数

$$
T=\binom{N}{2}.
$$

如果我们能数出**互不相交**（掩码按位与为 0）的对数 $D$，那就有

$$
f(n)=T-D.
$$

所以关键变为：如何计数“用到的数字集合恰好是某个掩码”的整数个数，并据此累加所有**不相交**集合对的乘积。

---

## 🧩 两层计数：$F(S)$ 与 $E(S)$

* $F(S)$：**允许集合计数**——使用的所有数字都属于集合 $S$ 的正整数个数。
  这会把“恰好用到子集 $T\subseteq S$”的数都算进去。
* $E(S)$：**恰好集合计数**——用到的数字集合**恰好**是 $S$ 的正整数个数。

两者满足**子集分解**：

$$
F(S)=\sum_{T\subseteq S}E(T).
$$

我们想要的互不相交对数自然写为：

$$
D=\sum_{\substack{S\cap T=\varnothing\\ S<T}} E(S)\cdot E(T).
$$

因此先算 $F$，再通过**子集莫比乌斯反演**求出 $E$，最后累加不相交对即可。

---

## 🧮 如何快速计算 $F(S)$

设 $L$ 为最大位数。本题针对 $n=10^{18}$，因此 $L=18$，而区间就是所有 1 位到 18 位的正整数。
对任意非空 $S\subseteq\{0,\dots,9\}$，记 $|S|=k$：

* 若 $0\in S$：首位不能为 0，其余位任取 $S$。长度为 $\ell$ 的数量：

  $$
  (k-1)\cdot k^{\ell-1}.
  $$

  累加 $\ell=1..L$ 得到

  $$
  F(S)=k^L-1.
  $$

* 若 $0\notin S$：首位没有限制，长度为 $\ell$ 的数量：

  $$
  k^\ell,
  $$

  累加 $\ell=1..L$ 得到

  $$
  F(S)=\sum_{\ell=1}^{L}k^\ell.
  $$

  > 这等价于等比数列的和 $\frac{k^{L+1}-k}{k-1}$，实现时用循环避免模意义下的除法。

> ⚠️ 这里之所以对是否包含 0 分开，是因为**正整数的最高位不能为 0**。

---

## 🔁 子集莫比乌斯反演（从 $F$ 得 $E$）

在子集格上有经典关系：

$$
F(S)=\sum_{T\subseteq S}E(T)
\quad\Longleftrightarrow\quad
E(S)=\sum_{T\subseteq S}(-1)^{|S|-|T|}F(T).
$$

代码里使用“**快速子集反演**”的等价写法（逐比特消去）即可在 $O(10\cdot 2^{10})$ 内完成。

---

## 🧾 互不相交对数 $D$

有了 $E$ 之后，直接枚举所有不相交掩码对：

$$
D=\sum_{\substack{S<T\\ S\cap T=\varnothing}} E(S)E(T).
$$

这里状态数 $2^{10}=1024$，对偶对约 $5.2\times 10^5$，常数很小，直接 $O(2^{20})$ 就行。

> 也可以用 SOS DP 做到 $O(10\cdot 2^{10})$：
>
> $$
> D=\frac12\sum_{S\neq\emptyset} E(S)\cdot \biggl(\sum_{T\subseteq \overline{S}}E(T)\biggr),
> $$
>
> 先对 $E$ 做一遍“子集和”预处理即可。但本题没必要。

---

## 🧮 总式

* 总对数 $T=\binom{N}{2}$，其中 $N=10^L-1$。
* 互不相交对数 $D$ 如上。
* 答案：

  $$
  f(n)=T-D\pmod{M},\quad M=1000267129.
  $$

---

## ✅ 样例自检

当 $n=100$（$L=2$）时，程序算得 $f(100)=1539$，与题面一致。

---

## ⏱ 复杂度

* 计算 $F$：$O(2^{10}\cdot L)$
* 反演 $F\to E$：$O(10\cdot 2^{10})$
* 枚举不相交对：$O((2^{10})^2)\approx 10^6$
* **总计**：$O(2^{20})$，毫秒级
* **空间**：两个长度 $2^{10}$ 的数组，$O(2^{10})$

---

## 💻 参考实现（含时间统计）

```cpp
#include <bits/stdc++.h>
using namespace std;

using LL = long long;
using i128 = __int128_t;

const LL MOD = 1000267129LL;

// 计算 f(10^L) mod MOD，区间为 [1, 10^L - 1]
LL solve_for_L(int L) {
    const int D = 10;
    const int M = 1 << D; // 掩码总数 1024

    // F[S]: 仅用 S 中数字、长度 1..L 的正整数个数（模 MOD）
    vector<LL> F(M, 0), E(M, 0);

    for (int S = 1; S < M; ++S) {
        int k = __builtin_popcount((unsigned)S); // |S|
        bool hasZero = (S & 1);                  // bit 0 代表数字 0

        if (hasZero) {
            // F[S] = k^L - 1
            LL p = 1 % MOD;
            for (int i = 0; i < L; ++i) p = (p * k) % MOD;
            F[S] = (p - 1 + MOD) % MOD;
        } else {
            // F[S] = sum_{len=1..L} k^len
            LL p = k % MOD, s = 0;
            for (int i = 1; i <= L; ++i) {
                s += p; if (s >= MOD) s -= MOD;
                p = (p * k) % MOD;
            }
            F[S] = s;
        }
    }

    // 子集莫比乌斯反演：由 F 得到 E（恰好使用集合 S）
    E = F;
    for (int b = 0; b < D; ++b) {
        for (int mask = 0; mask < M; ++mask) {
            if (mask & (1 << b)) {
                E[mask] -= E[mask ^ (1 << b)];
                if (E[mask] < 0) E[mask] += MOD;
            }
        }
    }

    // 互不相交对数 D = sum_{S<T, S&T=0} E[S]*E[T]
    LL dis = 0;
    for (int S = 1; S < M; ++S) if (E[S]) {
        for (int T = S + 1; T < M; ++T) if ((S & T) == 0 && E[T]) {
            dis = (dis + (LL)((i128)E[S] * E[T] % MOD)) % MOD;
        }
    }

    // 总对数 T = C(N,2)，N = 10^L - 1
    long long N = 1;
    for (int i = 0; i < L; ++i) N *= 10; // L<=18 安全
    N -= 1;

    LL T = (LL)((i128)N * (N - 1) / 2 % MOD);
    LL ans = T - dis;
    ans %= MOD;
    if (ans < 0) ans += MOD;
    return ans;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    auto t0 = chrono::steady_clock::now();

    // 样例：n=100 => L=2
    LL sample = solve_for_L(2);
    // 目标：n=10^18 => L=18
    LL answer = solve_for_L(18);

    auto t1 = chrono::steady_clock::now();
    double ms = chrono::duration<double, std::milli>(t1 - t0).count();

    cout << "f(100) = " << sample << "\n";
    cout << "f(10^18) mod 1000267129 = " << answer << "\n";
    cerr << "Time: " << fixed << setprecision(3) << ms << " ms\n";
    return 0;
}
```

---

## 🔍 正确性要点

1. **位掩码建模**将“有公共数字”转化为集合交非空，结构清晰。
2. **补集计数**规避“至少一个公共数字”的容斥复杂度，直接用 $T-D$。
3. **允许集合 $\to$ 恰好集合**：
   $F(S)=\sum_{T\subseteq S}E(T)$ 是自然分解；只有拿到 $E$，才能无重叠地判断“是否相交”。
4. **子集莫比乌斯反演**在线性时间（相对状态数）完成从 $F$ 到 $E$ 的还原。

---
