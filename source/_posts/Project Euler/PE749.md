---
title: PE749
date: 2025-5-28 00:35:55
mathjax: true
tags:
- PE
- Math
categories:
- Project Euler
---

## 问题描述

我们定义一个正整数 $n$ 为 **near power sum number**，如果存在正整数 $k$，使得：

$$
\sum_{d \in \text{digits}(n)} d^k = n - 1 \quad \text{或} \quad n + 1
$$

即，数字的 $k$ 次幂之和等于 $n\pm1$。

我们记 $S(D)$ 为所有 $d$ 位（$d \le D$）的 near power sum 数的总和。例如：
<!-- more -->

* $S(2) = 110$
* $S(6) = 2562701$

问题要求：

$$
\text{求 } S(16)
$$

---

## 解题思路

显然，如果暴力从 $1$ 到 $10^{16}$ 枚举每个数并判断是否为 near power sum 数，将会极其低效。

因此我们采用**反向构造** + **枚举数字组合**的策略。

### 核心思想

我们不去枚举每个可能的 $n$，而是：

1. 枚举幂次数 $k = 1$ 到某个上限；
2. 枚举数字位数 $L = 1$ 到 $D$；
3. 枚举所有数字组合（即每个数字出现的次数）；
4. 计算数字组合的幂和 $S$，尝试 $n = S \pm 1$ 是否成立；
5. 检查数字组合是否能组成 $n$；
6. 若成立，加入答案集合。

### 幂和限制剪枝

考虑 $L$ 位数字，合法的 $n$ 范围是：

$$
10^{L-1} \le n < 10^L
$$

因此数字幂和 $S$ 应满足：

$$
S \in [10^{L-1} - 1, 10^L - 1]
$$

这样 $n = S \pm 1$ 才可能落在有效范围。

---

## 时间复杂度分析

我们会枚举：

* 幂次数 $k$（最多到 $D$）；
* 位数 $L = 1$ 到 $D$；
* 每种数字分布（枚举将 $L$ 个位置分配到 10 个数字）：

$$
\text{复杂度为 } O(K \cdot \binom{D+9}{9})
$$

对 $D = 16$，这大约是数千万到一亿的搜索节点。加上剪枝优化，在现代计算机上可以在几秒内完成。

---

## C++ 实现

下面是封装优化后的代码，并添加了运行计时：

```cpp
#include <bits/stdc++.h>
#include <chrono>
using namespace std;
using namespace chrono;
using u64 = unsigned long long;

constexpr int MAX_D = 16;
u64 power_k[MAX_D + 1][10];
u64 pow10[MAX_D + 1];
set<u64> answers;

// 判断 n 的数字频率是否与 cnt[0..9] 匹配
bool match_digit_counts(u64 n, const int cnt[10]) {
    int actual[10] = {0};
    while (n > 0) {
        actual[n % 10]++;
        n /= 10;
    }
    for (int d = 0; d < 10; ++d)
        if (actual[d] != cnt[d])
            return false;
    return true;
}

// 递归枚举数字组合
void dfs(int idx, int remain, u64 sum,
         int k, int L, u64 low, u64 high, int cnt[10]) {
    if (sum + u64(remain) * power_k[k][9] < low) return;
    if (sum > high) return;

    if (idx == 10) {
        if (remain != 0) return;
        for (int delta : {-1, +1}) {
            u64 n = sum + delta;
            if (n >= pow10[L - 1] && n < pow10[L]) {
                if (match_digit_counts(n, cnt)) {
                    answers.insert(n);
                }
            }
        }
        return;
    }

    for (int c = 0; c <= remain; ++c) {
        cnt[idx] = c;
        dfs(idx + 1, remain - c, sum + u64(c) * power_k[k][idx],
            k, L, low, high, cnt);
    }
    cnt[idx] = 0;
}

// 主逻辑封装
u64 solve(int D) {
    answers.clear();

    for (int i = 0; i <= D; ++i)
        pow10[i] = (i == 0 ? 1 : pow10[i - 1] * 10);

    for (int k = 1; k <= D; ++k)
        for (int d = 0; d <= 9; ++d)
            power_k[k][d] = pow(d, k);

    int cnt[10] = {0};

    for (int k = 1; k <= D; ++k) {
        for (int L = 1; L <= D; ++L) {
            u64 low = pow10[L - 1] - 1;
            u64 high = pow10[L] - 1;
            dfs(0, L, 0, k, L, low, high, cnt);
        }
    }

    __uint128_t total = 0;
    for (u64 n : answers) total += n;

    // 打印 __uint128_t
    string result;
    while (total > 0) {
        result += char('0' + (total % 10));
        total /= 10;
    }
    reverse(result.begin(), result.end());
    if (result.empty()) result = "0";
    cout << "S(" << D << ") = " << result << endl;

    return 0;
}

int main() {
    auto start = high_resolution_clock::now();
    solve(16);
    auto end = high_resolution_clock::now();
    auto duration = duration_cast<milliseconds>(end - start);
    cout << "Execution time: " << duration.count() << " ms" << endl;
    return 0;
}
```

当然，下面是对你提供的 `dfs` 函数进行详细解析的解释，适合添加到你的博客或笔记中，帮助读者理解每个参数的意义以及整体递归逻辑。

---

### 深度优先搜索函数 `dfs` 详解

```cpp
void dfs(int idx, int remain, u64 sum,
         int k, int L, u64 low, u64 high, int cnt[10])
```

#### 参数说明

| 参数        | 类型      | 含义                                            |
| --------- | ------- | --------------------------------------------- |
| `idx`     | `int`   | 当前考虑的数字是几（0\~9）。表示我们正在尝试将当前 `idx` 个数字放入数字组合中。 |
| `remain`  | `int`   | 当前还有多少个数字位可以分配（总共应该分配 L 位）。                   |
| `sum`     | `u64`   | 当前数字组合对应的 `k` 次幂和。                            |
| `k`       | `int`   | 当前枚举的幂次数（即 digit^k）。                          |
| `L`       | `int`   | 枚举的目标数字长度（位数）。                                |
| `low`     | `u64`   | 当前位数下允许的最小幂和值，通常为 `10^(L-1) - 1`。             |
| `high`    | `u64`   | 当前位数下允许的最大幂和值，通常为 `10^L - 1`。                 |
| `cnt[10]` | `int[]` | 当前数字组合中各个数字出现的次数。`cnt[d]` 表示数字 `d` 出现了多少次。    |

---

#### 函数逻辑解析

##### 剪枝 1：不可能凑够下限

```cpp
if (sum + u64(remain) * power_k[k][9] < low) return;
```

* 即使剩下的所有数字都是 9，也不足以达到最低可能的幂和 `low`，可以直接返回。

##### 剪枝 2：超过上限

```cpp
if (sum > high) return;
```

* 当前累计的幂和 `sum` 已经超过 `high`，说明无论怎么填后面的数字，都不可能合法。

##### 递归终止条件

```cpp
if (idx == 10) {
    if (remain != 0) return;
    ...
}
```

* 枚举到了数字 `9`（即 idx == 10），此时必须刚好用完了所有 `L` 位数字，才进行判断。
* 检查 `sum ± 1` 是否构成合法的 near power sum number：

  ```cpp
  for (int delta : {-1, +1}) {
      u64 n = sum + delta;
      ...
  }
  ```
* 进一步验证 `n` 的数字组成是否和当前 `cnt` 匹配：

  ```cpp
  if (match_digit_counts(n, cnt))
      answers.insert(n);
  ```

##### 递归展开

```cpp
for (int c = 0; c <= remain; ++c) {
    cnt[idx] = c;
    dfs(idx + 1, remain - c, sum + u64(c) * power_k[k][idx], ...);
}
cnt[idx] = 0;
```

* 对当前数字 `idx`，尝试让它出现 `0~remain` 次；
* 每次尝试更新数字频率数组 `cnt`，更新剩余位数 `remain - c` 和当前幂和 `sum + c * idx^k`；
* 递归进入下一位数字；
* 递归完成后重置 `cnt[idx]`，以免影响其他分支。

---

#### 总体结构图解（以 L=3 为例）

假设我们在找三位数的组合，函数会构造所有可能的数字频率组合：

```
idx = 0, remain = 3
 ├── cnt[0]=0 → idx=1, remain=3
 │   ├── cnt[1]=0 → ...
 │   ├── cnt[1]=1 → ...
 │   ├── ...
 │   └── cnt[1]=3 → ...
 ├── cnt[0]=1 → idx=1, remain=2
 ├── cnt[0]=2 → idx=1, remain=1
 └── cnt[0]=3 → idx=1, remain=0
```

最终会覆盖所有满足：10 个数字中，总共分配了 `L` 位的频率组合。

---


---

## 运行结果

```
S(16) = 
Execution time: 434 ms
```
---

