---
title: PE530
date: 2025-5-28 00:55:57
mathjax: true
tags:
- PE
- Math
categories:
- Project Euler
---

## 问题描述

$$
F(N)\;=\;\sum_{n=1}^N \sum_{d\mid n}\gcd\Bigl(d,\tfrac nd\Bigr)
$$

<!-- more -->

---

## 1. 把内层“$\gcd$”化为φ函数之和

### 1.1. 关键恒等

对任意正整数 $a,b$，有

$$
\gcd(a,b)
\;=\;\sum_{t\,\mid\,\gcd(a,b)}\varphi(t),
$$

其中 $\varphi$ 为欧拉函数。
**证明思路**：用 Möbius 反演或常见的“把 $\gcd$ 表示为 $\sum\varphi$”的方法即可。

### 1.2. 应用于 $f(n)$

记

$$
f(n)=\sum_{d\mid n}\gcd\Bigl(d,\tfrac nd\Bigr).
$$

套用上式：

$$
\gcd\Bigl(d,\tfrac nd\Bigr)
=\sum_{t\mid d,\;t\mid\frac nd}\varphi(t).
$$

于是

$$
f(n)
=\sum_{d\mid n}\sum_{t\mid d,\;t\mid\frac nd}\varphi(t)
=\sum_{t^2\mid n}\varphi(t)\;\underbrace{\Bigl|\{\,d\mid n:\;t\mid d,\;t\mid\frac nd\,\}\Bigr|}_{\tau(n/t^2)}.
$$

换言之

$$
\boxed{\,f(n)=\sum_{t^2\,\mid\,n}\varphi(t)\,\tau\!\bigl(n/t^2\bigr)\,}.
$$

---

## 2. 交换求和，得到双重求和形式

把上式代入
$\displaystyle F(N)=\sum_{n=1}^N f(n)$，交换求和顺序：

$$
F(N)
=\sum_{n=1}^N\;\sum_{t^2\mid n}\varphi(t)\,\tau\!\bigl(n/t^2\bigr)
=\sum_{t\le\sqrt N}\varphi(t)\;\sum_{\substack{n\le N\\t^2\mid n}}\tau\!\bigl(n/t^2\bigr).
$$

令 $n=t^2m$，当 $n\le N$ 等价于 $m\le N/t^2$，于是

$$
\boxed{
F(N)
=\sum_{t=1}^{\lfloor\sqrt N\rfloor}\varphi(t)\;\sum_{m=1}^{\lfloor N/t^2\rfloor}\tau(m)
\;=\;\sum_{t=1}^{\sqrt N}\varphi(t)\;S\!\bigl(\lfloor N/t^2\rfloor\bigr),
}
$$

其中

$$
S(x)\;=\;\sum_{m=1}^x \tau(m).
$$

---

## 3. 如何高效计算 $S(x)$ 与 $\displaystyle \sum_{t\le T}\varphi(t)$?

* **$\varphi(t)$ 前缀**
  用**线性筛**在 $O(T)$ 预处理出 $\varphi(1\ldots T)$ 并累加前缀和 $\Phi(t)=\sum_{i\le t}\varphi(i)$。

* **$\tau(n)$ 前缀**
  当 $x$ 较小（比如 $x\le T$）时，可以暴力枚举 $\tau(1\ldots T)$ 并做前缀和。
  当 $x$ 较大时，用经典的“整除分块”在 $O(x^{2/3})$ 以内计算

  $$
  S(x)=\sum_{i=1}^x \tau(i)
       =\sum_{d=1}^x \Bigl\lfloor\frac x d\Bigr\rfloor
       =\sum_{l=1}^{x}\Bigl\lfloor\frac x l\Bigr\rfloor,
  $$

  并对不同商值分块累加，配合哈希表记忆化。

---

## 4. “枚举 $t$” 直接做 vs. 分块加速

如果直接按

$$
F(N)
=\sum_{t=1}^{\sqrt N}\varphi(t)\;S\bigl(\lfloor N/t^2\rfloor\bigr),
$$

枚举到 $t\approx N^{1/2}$，对 $N=10^{15}$ 显然太慢。优化思路是取

$$
T=\lfloor N^{1/3}\rfloor,
$$

把 $t$ 分成「小 $t\le T$」和「大 $t>T$」两部分。

### 4.1. 小 $t\le T$ 部分

直接

$$
\sum_{t=1}^T \varphi(t)\;S\!\bigl(\lfloor N/t^2\rfloor\bigr).
$$

枚举 $t$ 花费 $O(T)$。

### 4.2. 大 $t>T$ 部分

此时 $\lfloor N/t^2\rfloor\le N/T^2=T$，所以商值 $m=\lfloor N/t^2\rfloor$ 只有 $O(T)$ 个不同。对每个 $1\le m\le M$（后面给出 $M$）：

* 求出所有 $t$ 满足 $\lfloor N/t^2\rfloor=m$ 的区间，

  $$
    r_m=\Bigl\lfloor\sqrt{\tfrac N m}\Bigr\rfloor,\quad
    \ell_m=\Bigl\lfloor\sqrt{\tfrac N{m+1}}\Bigr\rfloor,
  $$

  则这些 $t$ 恰好落在 $(\ell_m,\,r_m]$。

* 在这些 $t$ 上累加
  $\displaystyle \sum_{t\in(\ell_m,r_m]}\varphi(t)=\Phi(r_m)-\Phi(\ell_m)$。

* 乘以 $S(m)$，得到这一块贡献：

  $$
  \sum_{t>\,T,\;\lfloor N/t^2\rfloor=m}
   \varphi(t)\;S(m)
  =\bigl[\Phi(r_m)-\Phi(\ell_m)\bigr]\;S(m).
  $$

取到何种 $m$ 即可呢？由 $t>T$ 且 $\lfloor N/t^2\rfloor=m$，有

$$
t>\,T
\quad\Longrightarrow\quad
m=\Bigl\lfloor\frac N{t^2}\Bigr\rfloor \;\le\;\Bigl\lfloor\frac N{(T+1)^2}\Bigr\rfloor.
$$

于是令

$$
M\;=\;\Bigl\lfloor\frac N{(T+1)^2}\Bigr\rfloor,
$$

对 $m=1\ldots M$ 做这一步。

### 4.3. 合并

最终

$$
\boxed{
F(N)
=\underbrace{\sum_{t=1}^T \varphi(t)\;S\bigl(\lfloor N/t^2\rfloor\bigr)}_{\text{枚举小 }t}
\;+\;
\underbrace{\sum_{m=1}^M S(m)\,\bigl[\Phi(r_m)-\Phi(\ell_m)\bigr]}_{\text{分块大 }t}.
}
$$

复杂度：

* 线性筛与小 $t$ 枚举：$O(T)$；
* 建立小规模 $\tau$、$\varphi$ 前缀：$O(T\log T)$；
* $S(x)$ 与 $\Phi(x)$ 分块：均摊 $O(N^{1/3}\log N)$。

对于 $N=10^{15}$，有

$$
T\approx (10^{15})^{1/3}=10^5,
\quad
M\approx \frac{10^{15}}{(10^5)^2}=10^5,
$$

总体可在几秒内跑完。

---

## 5. 示例：算 $F(10)$ 的流程

* 目标：$N=10$，取 $T=\lfloor10^{1/3}\rfloor=2$，$M=\lfloor10/3^2\rfloor=1$。

###  预处理

* $\varphi(1)=1,\;\varphi(2)=1$，前缀 $\Phi(0)=0,\Phi(1)=1,\Phi(2)=2$。
* $\tau(1)=1,\tau(2)=2$，前缀 $S(1)=1,S(2)=3$。

###  小 $t\le2$

$$
\sum_{t=1}^2\varphi(t)\;S\!\bigl(\lfloor10/t^2\rfloor\bigr)
= \varphi(1)\,S(10) + \varphi(2)\,S(2).
$$

* 直接算 $S(10)=\sum_{i=1}^{10}\tau(i)=1+2+2+3+2+4+2+4+3+4=27$。
* $S(2)=3$。
  所以这部分是 $1\cdot27+1\cdot3=30$。

### 大 $t>2$

这里只有 $M=1$：

* 对 $m=1$：

  $$
  r_1=\Bigl\lfloor\sqrt{10/1}\Bigr\rfloor=3,\quad
  \ell_1=\Bigl\lfloor\sqrt{10/2}\Bigr\rfloor=2.
  $$

  $\Phi(3)-\Phi(2)=\bigl(1+1+2\bigr)-(1+1)=2$。
  $S(1)=1$。
  贡献 $=1\times2=2$。

### 合计

$$
F(10)=30+2=32,
$$

与题给一致。

---


```
#include <bits/stdc++.h>
using namespace std;
using int64 = long long;
using namespace chrono;


static const int64 N_TEST1 = 10;
static const int64 N_TEST2 = 1000;
static const int64 N_BIG   = 1000000000000000LL;

int64 N, T, M;
vector<int>     phi;
vector<int64>   prefPhi;
vector<int64>   prefS;
vector<int>     tau;
unordered_map<int64,int64> cacheS, cachePhi;

// 精确整数平方根
int64 isqrt(int64 x) {
    int64 r = floor(sqrt((long double)x));
    while ((r+1)*(r+1) <= x) ++r;
    while (r*r > x) --r;
    return r;
}

// 1) 线性筛到 T：phi[i], prefPhi[i]
void build_phi() {
    phi.assign(T+1, 0);
    vector<bool> isC(T+1,false);
    vector<int> primes;
    phi[1]=1;
    for(int i=2;i<=T;i++){
        if(!isC[i]){
            primes.push_back(i);
            phi[i]=i-1;
        }
        for(int p:primes){
            int64 v=1LL*p*i;
            if(v> T) break;
            isC[v]=true;
            if(i%p==0){
                phi[v]=phi[i]*p;
                break;
            } else {
                phi[v]=phi[i]*(p-1);
            }
        }
    }
    prefPhi.assign(T+1,0);
    for(int i=1;i<=T;i++)
        prefPhi[i]=prefPhi[i-1]+phi[i];
}

// 2) 暴力算 tau[i] & prefS[i] 到 T
void build_tau() {
    tau.assign(T+1,0);
    prefS.assign(T+1,0);
    for(int i=1;i<=T;i++){
        for(int j=i;j<=T;j+=i)
            tau[j]++;
    }
    for(int i=1;i<=T;i++)
        prefS[i]=prefS[i-1]+tau[i];
}

// 3) S(x) = sum_{n<=x} tau(n) 分块缓存
int64 S(int64 x){
    if(x<=T) return prefS[x];
    auto it=cacheS.find(x);
    if(it!=cacheS.end()) return it->second;
    int64 ans=0;
    for(int64 l=1, r;l<=x; l=r+1){
        int64 v=x/l;
        r = x/v;
        ans += v*(r-l+1);
    }
    return cacheS[x]=ans;
}

// 4) Phi(x) = sum_{n<=x} phi(n) 递归缓存
int64 Phi(int64 x){
    if(x<=T) return prefPhi[x];
    auto it=cachePhi.find(x);
    if(it!=cachePhi.end()) return it->second;
    int64 ans = x*(x+1)/2;
    int64 last = isqrt(x);
    // 分块 i from 2..x:
    // do blocks where x/i is constant
    for(int64 l=2, r; l<=x; l=r+1){
        int64 v = x/l;
        r = x/v;
        ans -= (r-l+1) * Phi(v);
    }
    return cachePhi[x]=ans;
}

// 5) 计算 F(N)
int64 calc_F(int64 N_){
    N=N_;
    T = floor(cbrt((long double)N)) + 1;
    M = N/((T+1)*(T+1));  // floor

    build_phi();
    build_tau();
    cacheS.clear();
    cachePhi.clear();

    int64 ans = 0;
    // —— 第一部分
    for(int64 t=1; t<=T; t++){
        int64 m = N/(t*t);
        if(m==0) break;
        ans += (int64)phi[t] * S(m);
    }
    // —— 第二部分
    for(int64 m=1; m<=M; m++){
        int64 l = isqrt(N/(m+1));
        int64 r = isqrt(N/m);
        if(r> l){
            ans += S(m) * ( Phi(r) - Phi(l) );
        }
    }
    return ans;
}

int main(){
    auto start = high_resolution_clock::now();
    cout<<"F(10^15)="<<calc_F(N_BIG)<<"\n";
    auto end = high_resolution_clock::now();
    auto duration = duration_cast<milliseconds>(end - start);
    cout << "Execution time: " << duration.count() << " ms" << endl;
    return 0;
}
```