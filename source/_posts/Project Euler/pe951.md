---
title: PE932
date: 2025-6-28 15:54:38
mathjax: true
tags:
  - PE
  - Math
categories:
  - Project Euler
---

## 1. 题意

给定一副共有 $2n$ 张卡片的牌堆，其中恰好有 $n$ 张红牌和 $n$ 张黑牌。两名玩家按如下规则轮流操作：

1. 玩家移除牌堆顶端的一张牌，记下其颜色。
2. 如果此时牌堆不为空，且新顶端的卡片与刚移除的牌颜色相同，则掷一枚公平硬币：

   - 正面（概率 $\tfrac12$）：再移除该顶端卡片（同一回合移除两张）；
   - 反面（概率 $\tfrac12$）：不再移除，回合结束。

如此交替进行，直至所有卡片被移完。**移除最后一张牌的玩家获胜**。

我们称一个起始牌序为 **公平**，当且仅当先手和后手的获胜概率都恰好为 $\tfrac12$。记 $F(n)$ 为长度 $2n$ 且含 $n$ 红 $n$ 黑的公平序列数。

<!-- more -->

---

## 2. 解题思路

### 2.1 回合数与胜负的对应

- 定义一次玩家轮到开始移除牌（无论是拿 1 张还是 2 张）为 **一次回合**。
- 第 1 回合为先手，第 2 回合为后手，第 3 回合回到先手……因此 **奇数回合由先手执行**，**偶数回合由后手执行**。
- 若总回合数 $N$ 为奇数，则先手在第 $N$ 回合拿走最后一张牌，先手胜；否则后手胜。

由此

$$
P(\text{先手胜}) = P(N\text{ 为奇数}).
$$

### 2.2 Run（同色连续段）的拆分

将起始牌序按颜色连续段（run）划分，记有 $k$ 段，长度分别为
$L_1, L_2, \dots, L_k.$
每段在消除过程中的回合数相互独立，总回合数
$N = \sum_{i=1}^k T_{L_i},$
其中 $T_{L_i}$ 是长度为 $L_i$ 的那段所需的回合数。

### 2.3 单段的概率生成函数（PGF）

记长度为 $L$ 的 run 对应的回合数为随机变量 $T_L$。定义其 PGF：

$$
g_L(z) = E[z^{T_L}] = \sum_{t\ge1}P(T_L=t)\,z^t.
$$

- **边界**：

  - $g_0(z)=1$（空段不消耗回合）
  - $g_1(z)=z$（一回合必拿掉）

- **递推**（$L\ge2$）：首回合掷硬币：

  - 反面（概率 $\tfrac12$）：只拿 1 张 ⇒ 贡献 $z\,g_{L-1}(z)$
  - 正面（概率 $\tfrac12$）：拿 2 张 ⇒ 贡献 $z\,g_{L-2}(z)$

合并：

$$
g_L(z)=\tfrac12\,z\bigl(g_{L-1}(z)+g_{L-2}(z)\bigr),
\quad L\ge2.
$$

### 2.4 整副牌的 PGF 及“公平”条件

总回合数 $N$ 的 PGF：

$$
G(z)=E[z^N]=\prod_{i=1}^k g_{L_i}(z).
$$

要先手胜率等于 $\tfrac12$，即

$$
P(N\text{ 奇}) = \tfrac12.
$$

利用“奇偶”提取技巧：

$$
G(-1)=\sum_nP(N=n)(-1)^n = P(N\text{ 偶}) - P(N\text{ 奇}).
$$

又有
$P(N\text{ 偶})+P(N\text{ 奇})=1$
，解得

$$
P(N\text{ 奇})=\frac{1-G(-1)}2.
$$

因此 **公平** ⇔ $G(-1)=0$。

### 2.5 在 $z=-1$ 处求单段值 $h_L$

令
$
h_L=g_L(-1)$.
带入递推：

$$
\begin{cases}
 h_0=1,\\
 h_1=-1,\\
 h_L=-\tfrac12\bigl(h_{L-1}+h_{L-2}\bigr),\quad L\ge2.
\end{cases}
$$

计算前几项：

- $h_2=-\tfrac12((-1)+1)=0$
- $h_3=-\tfrac12(0+(-1))=\tfrac12\neq0$
- $h_4=-\tfrac12(h_3+h_2)=-\tfrac14\neq0$

可见 **仅当 $L=2$ 时** 有 $h_L=0$。

### 2.6 从乘积到“存在零因子”与最终 DP

总 PGF 在 $-1$ 处：

$$
G(-1)=\prod_{i=1}^k h_{L_i}.
$$

乘积为零当且仅当**至少存在一个**因子为零，
即**存在某段 run 长度恰为 2**。

**结论**：公平排列 ⇔ 起始牌序包含至少一个长度为 2 的 run。

令
$A(n)=\text{不含 run=2 的二色序列数},$
则

$$
F(n)=\binom{2n}{n}-A(n).
$$

可以用以下 DP 计数 $A(n)$：

```cpp
// dp[i][j][c][l]: i 红, j 黑, 末尾色 c, run 长度状态 l=1,2,3(>=3)
for i=0..n, j=0..n, c=0..1, l=1..3:
  转移：
    // 续色 c
    if (可放同色) dp[i+?][j+?][c][min(3,l+1)] += dp[i][j][c][l];
    // 换色：仅当 l!=2
    if (l!=2 && 可放另一色) dp[...] += ...;
```

最终累加 `dp[n][n][c][l]` 中 `l=1,3` 两种。

---

## 3. 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
using LL = long long;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n = 26;  // 示例计算 F(26)
    auto t1 = chrono::high_resolution_clock::now();

    // 1) 预计算 C(2n,n)
    LL C = 1;
    for (int i = 1; i <= n; i++) {
        C = C * (n + i) / i;
    }

    // 2) DP 计算 A(n)
    static LL dp[27][27][2][4];
    memset(dp, 0, sizeof(dp));
    dp[1][0][0][1] = 1;
    dp[0][1][1][1] = 1;
    for (int i = 0; i <= n; i++) {
        for (int j = 0; j <= n; j++) {
            for (int c = 0; c < 2; c++) {
                for (int l = 1; l <= 3; l++) {
                    LL v = dp[i][j][c][l];
                    if (!v)
                        continue;
                    // 续同色
                    if ((c == 0 && i < n) || (c == 1 && j < n)) {
                        int nl = (l == 1 ? 2 : 3);
                        dp[i + (c == 0)][j + (c == 1)][c][nl] += v;
                    }
                    // 换色（l!=2）
                    if (l != 2) {
                        int nc = c ^ 1;
                        if (nc == 0 && i < n)
                            dp[i + 1][j][nc][1] += v;
                        if (nc == 1 && j < n)
                            dp[i][j + 1][nc][1] += v;
                    }
                }
            }
        }
    }
    LL A = 0;
    for (int c = 0; c < 2; c++) {
        A += dp[n][n][c][1] + dp[n][n][c][3];
    }

    // 3) 计算 F(n)
    LL F = C - A;
    auto t2 = chrono::high_resolution_clock::now();
    double ms = chrono::duration<double, milli>(t2 - t1).count();

    cout << "F(" << n << ") = " << F << "\n";
    cout << "Elapsed time: " << fixed << setprecision(3) << ms << " ms\n";

    return 0;
}

// F(26) = 495568995495726
// Elapsed time: 0.023 ms
```
